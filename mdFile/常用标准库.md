#go

标准库查看网址：
https://studygolang.com/pkgdoc

# context

package context 的主要作用是为了在一组 goroutines 间传递上下文信息（cancel signal，deadline，request-scoped value）以达到对它们的管理控制。
在实际的生产环境中，我们可能会需要多个协程来实现具体的业务，为此我们需要确保父子协程之间的能够共享一些元数据与全局变量，并能够被同时关闭，context中的各类功能就是为此而设计的。


## 源码
context 是一个==接口==，某个类型只要实现了其申明的所有方法，便实现了 context。看下 context 的定义。
```go
// go version 1.18.10
type Context interface {
    Deadline() (deadline time.Time, ok bool)
    Done() <-chan struct{}
    Err() error
    Value(key any) any
}
```

`Deadline()`返回一个完成工作的截止时间，表示上下文应该被取消的时间。如果 ok为false则表示没有设置截止时间。

`Done()`返回一个==只读==的Channel，这个 Channel 会在当前工作完成时被关闭，表示上下文应该被取消。如果无法取消此上下文，则 Done 可能返回 nil。多次调用 Done 方法会返回同一个 Channel。一旦Channel关闭，通过广播机制，所有的监听goroutine都能够收到关闭信息。

`Err()`返回 Context 结束的原因，它只会在 Done 方法对应的 Channel 关闭时返回非空值。如果 Context 被取消，会返回context.Canceled 错误；如果 Context 超时，会返回context.DeadlineExceeded错误。

`Value()`从 Context 中获取键对应的值。如果未设置 key 对应的值则返回 nil。以相同 key 多次调用会返回相同的结果。

## 基础函数
context 包中提供了两个创建空 Context 的函数：
```go
// TODO 返回一个非 nil 但空的上下文。
// 当不清楚要使用哪种上下文或无可用上下文尚应使用 context.TODO。
func TODO() Context

// Background 返回一个非 nil 但空的上下文。
// 它不会被 cancel，没有值，也没有截止时间。它通常由 main 函数、初始化和测试使用，并作为处理请求的顶级上下文。
func Background() Context
```

与另外四个基于父级创建不同类型 Context 的函数：
```go
// WithCancel 基于父级创建一个具有 Done channel 的 context，可手动控制任务的取消
func WithCancel(parent Context) (Context, CancelFunc)

// WithDeadline 基于父级创建一个不晚于 d 结束的 context，可指定特定的时间点控制超时
func WithDeadline(parent Context, d time.Time) (Context, CancelFunc)

// WithTimeout 等同于 WithDeadline(parent, time.Now().Add(timeout))
func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)

// WithValue 基于父级创建一个包含指定 key 和 value 的 context，可用于传递数据
func WithValue(parent Context, key, val any) Context
```


## 基础使用

我们日常编写代码时，Context 对象会被被约定作为函数的第一个参数传递，eg：
```go
func users(ctx context.Context, request *Request) {
    // ... code
}
```

在函数中，我们可以通过 **ctx** 参数来获取相关的 Context 数据，并以此实现对于代码超时的设定：

```go
deadline, tiktok := ctx.Deadline()
if tiktok && deadline.Before(time.Now()) {
    // 超时
    return
}
```

### context 控制 goroutine 的生命周期

我们在开发中使用 goroutine来实现，而context能够用于控制goroutine的生命周期，从而避免出现 goroutine 泄漏或者不必要的等待操作。

例如：

```go
func users(ctx context.Context, req *Request) {
    // 启动一个 goroutine 来处理请求
    go func() {
        // 处理请求...
    }()
}
```

上面的代码中，我们启动了一个 goroutine 来处理请求，但是没有任何方式来控制这个 goroutine 的生命周期，如果这个请求被取消了，那么这个 goroutine 就会一直存在，直到它完成为止。为了避免这种情况的发生，我们可以使用 Context 来控制 goroutine 的生命周期：

```go
func users(ctx context.Context, req *Request) {
    // 启动一个 goroutine 来处理请求
    go func(ctx context.Context) {
        // 处理请求...
    }(ctx)
}
```

### 使用 WithValue() 传递数据

除了用于控制 goroutine 的生命周期，Context 还可以被用来在不同的 goroutine 之间传递请求域的相关数据。对于 Web 服务端开发，往往希望将一个请求处理的整个过程串起来，这就非常依赖于 Thread Local（对于 Go 可理解为单个协程所独有） 的变量，而在 Go 语言中并没有这个概念，因此需要在函数调用的时候传递 context。我们可以使用 Context 的 **WithValue()** 方法，例如：

```go
type key int

const (
    userKey key = iota
)

func users(ctx context.Context, req *Request) {
    // 从请求中获取用户信息
    user := req.GetUser
    // 将用户信息保存到 Context 中
    ctx = context.WithValue(ctx, userKey, user)
    
    // 启动一个 goroutine 来处理请求
    go func(ctx context.Context) {
        // 从 Context 中获取用户信息
        user := ctx.Value(userKey).(*User)
    
        // 处理请求...
    }(ctx)

}
```

在上面的代码中，我们定义了一个 `key`类型的常量 `userKey`，然后在 `users()`函数中将用户信息保存到了 Context 中，并将 Context 对象传递给了 goroutine 函数。

在 goroutine 函数中，我们使用 `ctx.Value()`方法来获取 Context 中保存的用户信息。

>[!info]
> 注：
> Context 中保存的键值对数据应该是线程安全的，因为它们可能会在多个 goroutine 中同时访问。


### 使用 WithCancel() 取消操作

除了控制 goroutine 的生命周期和传递数据之外，Context 还可以被用来执行取消操作。为了实现这个目的，我们可以使用 Context 的 `WithCancel()`方法，eg：

```go
func users(ctx context.Context, req *Request) {
    // 创建一个可以取消的 Context 对象
    ctx, cancel := context.WithCancel(ctx)

    // 启动一个 goroutine 来处理请求
    go func(ctx context.Context) {
        // 等待请求完成或者被取消
        select {
        case <-time.After(time.Second):
            // 请求完成
            fmt.Println("Request finish")
        case <-ctx.Done():
            // 请求被取消
            fmt.Println("Request canceled")
        }
    }(ctx)

    // 等待一段时间后取消请求
    time.Sleep(time.Millisecond * 800)
    cancel()
}
```

在上面的代码中，我们使用 WithCancel() 方法创建了一个可以取消的 Context 对象，并将取消操作封装在了一个 cancel() 函数中。然后我们启动了一个 goroutine 函数，使用 select 语句等待请求完成或者被取消，最后在主函数中等待一段时间后调用 cancel() 函数来取消请求来模拟请求超时后的自动取消。==调用cancel()的时候将关闭对应ctx中的Done通道，由此所有使用该ctx的goroutine都能收到信号来实现所有goroutine的取消。==

### 使用 WithDeadline() 设置截止时间

除了使用 WithCancel() 方法进行取消操作之外，Context 还可以被用来设置截止时间，以便在超时的情况下==自动==取消请求。为了实现这个目的，我们可以使用 Context 的 WithDeadline() 方法，eg：

```go
func users(ctx context.Context, req *Request) {
    // 设置请求的截止时间为当前时间加上 1 秒钟
    ctx, cancel := context.WithDeadline(ctx, time.Now().Add(time.Second))

    // 启动一个 goroutine 来处理请求
    go func(ctx context.Context) {
        // 等待请求完成或者超时
        select {
            case <-time.After(time.Millisecond * 500):
            // 请求完成
            fmt.Println("Request finish")
            case <-ctx.Done():
            // 请求超时或者被取消
            fmt.Println("Request canceled or timed out")
        }
    }(ctx)

    // 等待一段时间后取消请求
    time.Sleep(time.Millisecond * 1500)
    cancel()
}
```

在上面的代码中，我们使用 WithDeadline() 方法设置了一个截止时间为当前时间加上 1 秒钟的 Context 对象，并将超时操作封装在了一个 cancel() 函数中。然后我们启动了一个 goroutine 函数，使用 select 语句等待请求完成或者超时，最后在主函数中等待一段时间后调用 cancel() 函数来取消请求。

> [!info]
> 在使用 WithDeadline() 方法设置截止时间的时候，如果截止时间已经过期，则 Context 对象将被立即取消。

### 使用 WithTimeout() 设置超时时间

除了使用 **WithDeadline()** 方法进行截止时间设置之外，Context 还可以被用来设置超时时间，已实现==自动==取消请求，为了实现这个目的，我们可以使用 Context 的 **WithTimeout()** 方法，eg：

```go
func users(ctx context.Context, req *Request) {
    // 设置请求的超时时间为 1 秒钟
    ctx, cancel := context.WithTimeout(ctx, time.Second)

    // 启动一个 goroutine 来处理请求
    go func(ctx context.Context) {
        // 等待请求完成或者超时
        select {
        case <-time.After(time.Millisecond * 500):
            // 请求完成
            fmt.Println("Request completed")
        case <-ctx.Done():
            // 请求超时或者被取消
            fmt.Println("Request canceled or timed out")
        }
    }(ctx)

    // 等待一段时间后取消请求
    time.Sleep(time.Millisecond * 1500)
    cancel()
}
```

在上面的代码中，我们使用 WithTimeout() 方法设置了一个超时时间为 1 秒钟的 Context 对象，并将超时操作封装在了一个 cancel() 函数中。然后我们启动了一个 goroutine 函数，使用 select 语句等待请求完成或者超时，最后在主函数中等待一段时间后调用 cancel() 函数来取消请求。

>[!info]
> 需要注意的是，在使用 WithTimeout() 方法设置超时时间的时候，如果超时时间已经过期，则 Context 对象将被立即取消。

### context的传递

在一个应用程序中，不同的 goroutine 可能需要共享同一个 Context 对象。为了实现这个目的，Context 对象可以通过函数调用或者网络传输等方式进行传递。

例如，我们可以在一个处理 HTTP 请求的函数中创建一个 Context 对象，并将它作为参数传递给一个数据库查询函数，以便在查询过程中使用这个 Context 对象进行取消操作。代码 eg：

```go
func users(ctx context.Context, req *Request) {
    // 在处理 HTTP 请求的函数中创建 Context 对象
    ctx, cancel := context.WithTimeout(ctx, time.Second)
    defer cancel()
    
    // 调用数据库查询函数并传递 Context 对象
    result, err := findUserByName(ctx, req)
    if err != nil {
        // 处理查询错误...
    }
    
    // 处理查询结果...
}

func findUserByName(ctx context.Context, req *Request) (*Result, error) {
    // 在数据库查询函数中使用传递的 Context 对象
    rows, err := db.QueryContext(ctx, "SELECT * FROM users WHERE name = ?", req.Name)
    if err != nil {
     // 处理查询错误...
   }
   defer rows.Close()
   // 处理查询结果...
}
```

在上面的代码中，我们在处理 HTTP 请求的函数中创建了一个 Context 对象，并将它作为参数传递给了一个数据库查询函数 `findUserByName()`。在 `findUserByName()` 函数中，我们使用传递的 Context 对象来调用 `db.QueryContext()` 方法进行查询操作。由于传递的 Context 对象可能会在查询过程中被取消，因此我们需要在查询完成后检查查询操作的错误，以便进行相应的处理。

>[!info]
> 在进行 Context 的传递时，我们需要保证传递的 Context 对象是原始 Context 对象的子 Context，以便在需要取消操作时能够同时取消所有相关的 goroutine。如果传递的 Context 对象不是原始 Context 对象的子 Context，则取消操作只会影响到当前 goroutine，而无法取消其他相关的 goroutine。



## 参考文章

[(18条消息) Go Context 详解之终极无惑_恋喵大鲤鱼的博客-CSDN博客](https://blog.csdn.net/K346K346/article/details/122589609)
[Go 语言基础之 Context 详解 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/628201027)
[(18条消息) Go context详解_go的context_stevsun的博客-CSDN博客](https://blog.csdn.net/u013474436/article/details/108410246)

---
# encoding/json

`import "encoding/json"`

json包实现了json对象的编解码，参见[RFC 4627](http://tools.ietf.org/html/rfc4627)。Json对象和go类型的映射关系请参见Marshal和Unmarshal函数的文档。

参见"JSON and Go"获取本包的一个介绍：[http://golang.org/doc/articles/json_and_go.html](http://golang.org/doc/articles/json_and_go.html)

## 简单示例

`encoding/json`是Go语言标准库中提供的用于JSON编码和解码的包。它提供了一种简单而灵活的方式来处理JSON数据。下面是一个使用`encoding/json`进行JSON编码和解码的示例：

```go
package main

import (
	"encoding/json"
	"fmt"
)

type Person struct {
	Name string `json:"name"`
	Age  int    `json:"age"`
}

func main() {
	// 编码为JSON
	person := Person{Name: "Alice", Age: 25}
	jsonData, err := json.Marshal(person)
	if err != nil {
		fmt.Println("JSON encoding error:", err)
		return
	}
	fmt.Println(string(jsonData))

	// 解码JSON
	var decodedPerson Person
	err = json.Unmarshal(jsonData, &decodedPerson)
	if err != nil {
		fmt.Println("JSON decoding error:", err)
		return
	}
	fmt.Println(decodedPerson)
}
```

在上面的代码中，我们定义了一个`Person`结构体，它有两个字段：`Name`和`Age`。我们使用`json`标签来指定JSON对象中字段的名称。

首先，我们使用`json.Marshal()`函数将`Person`结构体编码为JSON格式的字节切片。如果编码过程中出现错误，我们会打印错误信息。然后，我们使用`fmt.Println()`函数将编码后的JSON数据以字符串形式打印出来。

接下来，我们使用`json.Unmarshal()`函数将JSON数据解码为`Person`结构体。解码过程中，我们需要提供一个指向目标结构体的指针作为参数。如果解码过程中出现错误，我们会打印错误信息。最后，我们使用`fmt.Println()`函数将解码后的`Person`结构体打印出来。

通过使用`encoding/json`包，我们可以很方便地进行JSON数据的编码和解码操作。它提供了丰富的功能，例如处理嵌套结构体、自定义字段名称、处理空值等。详细的用法和更多功能可以参考Go语言官方文档中的`encoding/json`包文档。

## 基本规则

go主要有两种方式将数据和json进行转换：
1. json与结构体相互转换
2. json和`map[string]any`和`[]map[string]any`进行转换

详细来讲有如下几个规则或特性：

- 只有合法的json串才能解析
```text
key只能是string；
map的形式必须是map[string]T，T是Go的基本类型；
Channel, complex, function 不能进行编码；
循环数据不支持；
指针会被编码成指针的值，nil是null。
```

- 只有可导出（exported）的字段才能解析
```text
即首字符大写的字段才能显示在json对象中，解析规则有如下顺序，例如一个key：Foo
1.先找tag是Foo的
2.找字段名是Foo的
3.找FOO或者FoO等
```

- 只能解码在目标对象存在的字段
```text
1. 这个特性其实是很有用的，你可以设计一个大而全的兼容结构体，当你希望从里面挑选一些字段时就可以利用它；
2. 这也意味着目标对象中unexported的字段不受Unmarshal的影响；
```

- Unmarshal可以自动对对象内部的指针赋值
```go
//这个特性是指一个struct包含其他的引用类型的字段，你不需要先创建它
//看下面的例子，对于Parents这个数组你不需要提前声明，有值就自动创建好，没值就是nil
type FamilyMember struct {
	Name    string	`json:"name"`
	Age     int	`json:"age"`
	Parents []string
}
b := []byte(`{"Name":"Wednesday","Age":6,"Parents":["Gomez","Morticia"]}`)
var m FamilyMember
err := json.Unmarshal(b, &m)
```

## 类库解析

**主要的接口和结构**

- **Marshaler**

核心的encode接口，为第三方提供了encode的可能性。

```go
// Marshaler is the interface implemented by types that
// can marshal themselves into valid JSON.
type Marshaler interface {
	MarshalJSON() ([]byte, error)
}
```

- **Unmarshaler**

同上，核心的decode接口

```go
// Unmarshaler is the interface implemented by types
// that can unmarshal a JSON description of themselves.
// The input can be assumed to be a valid encoding of
// a JSON value. UnmarshalJSON must copy the JSON data
// if it wishes to retain the data after returning.
//
// By convention, to approximate the behavior of Unmarshal itself,
// Unmarshalers implement UnmarshalJSON([]byte("null")) as a no-op.
type Unmarshaler interface {
	UnmarshalJSON([]byte) error
}
```

- Decoder / Encoder：解码输入流和编码json到输出流的对象
- UnmarshalTypeError：最主要的错误类型，表示一个json值不能转化为特定的go类型的值，还提供了其他若干Error类型，不一一列举了。
- Number：实际上是json的number类型的包装类，解析时提供对应方法取得值
- RawMessage：保持原本的json对象。实现了Marshaler和Unmarshaler接口，用于延迟json的解码或者预计算json的编码。前面是注释的翻译，其实就是个[]byte，delay和预计算没理解什么意思，这个类型在encode和decode过程中也没有用到。

## 重要函数

其中最主要的就是Marshal和Unmarshal两个方法，有很多细节需要注意。

**Marshal**

```go
func Marshal(v interface{}) ([]byte, error) {
```

Marshal函数返回v的json编码。

数组和切片类型的值编码为json数组，但[]byte编码为base64编码字符串；nil切片编码为null；结构体编码为json对象。每一个导出字段变成该对象的一个成员，除非：

> 1. 字段的标签是"-"  
> 2. 字段是空值，而其标签指定了omitempty选项

空值包括false、0、""、nil指针、nil接口、长度为0的数组、切片、映射。（经测试，空值是可以正常解析并显示的，tag里加上omitempty后就会被忽略掉）
```txt
// 字段被本包忽略
Field int `json:"-"`
// 字段在json里的键为"myName"
Field int `json:"myName"`
// 字段在json里的键为"myName"且如果字段为空值将在对象中省略掉
Field int `json:"myName,omitempty"`
// 字段在json里的键为"Field"（默认值），但如果字段为空值会跳过；注意前导的逗号
Field int `json:",omitempty"`
```
"string"选项标记一个字段在编码json时应编码为字符串。它只适用于字符串、浮点数、整数类型的字段。（这在对象转换过程中非常有用，避免了类型必须一致的尴尬，可动态调整目标对象，提高了灵活性）

```go
id int64 `json:"id,string"`
```

map类型的值编码为json对象，键必须是字符串，对象的键直接使用map的key。指针类型的值编码为其指向的值，nil指针编码为null。接口类型的值编码为接口内保持的具体类型的值，nil接口编码为null。

**Unmarshal**

```go
func Unmarshal(data []byte, v interface{}) error {
```

Unmarshal函数解析json编码的数据并将结果存入v指向的值。

要将json数据解码写入一个指针，Unmarshal函数首先处理json数据是json字面值null的情况。此时，函数将指针设为nil；否则，函数将json数据解码写入指针指向的值；如果指针本身是nil，函数会先申请一个值并使指针指向它。

要将json数据解码写入一个结构体，函数会匹配输入对象的键和Marshal使用的键（结构体字段名或者它的标签指定的键名），优先选择精确的匹配，但也接受大小写不敏感的匹配。

JSON的null值解码为go的接口、指针、切片时会将它们设为nil

**Compact**：将json编码的src中无用的空白字符剔除后写入dst

```go
func Compact(dst *bytes.Buffer, src []byte) error
```

**Indent**：将json编码的调整缩进之后写入dst，说白了就是美化一下，加个缩进啥的

```go
func Indent(dst *bytes.Buffer, src []byte, prefix, indent string) error
```

## 源码解析
源码解析可见[[常用标准库#encoding/json#参考文章]]





## 参考文章

[Go语言encoding/json库源码分析 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/37165706)


---
# encoding/xml
`import "encoding/xml"`

encoding/xml包的作用与encoding/json包的作用是类似的，`encoding/xml`包是Go语言标准库中用于XML编码和解码的包，它提供了一些函数和结构体来处理XML数据。

## 基础用法

首先，我们需要引入`encoding/xml`包：
```go
import "encoding/xml"
```

接下来，我们来看一下`encoding/xml`包中最常用的两个函数：`xml.Marshal()`和`xml.Unmarshal()`。

`xml.Marshal()`函数用于将Go数据结构编码为XML格式的数据。它的函数签名如下：
```go
func Marshal(v interface{}) ([]byte, error)
```

`v`是要编码的Go数据结构，它可以是任意的结构体、切片、映射等。该函数会返回编码后的XML数据和一个可能出现的错误。

下面是一个示例代码，演示了如何使用`xml.Marshal()`函数将Go结构体编码为XML格式：
```go
type Person struct {
    Name string `xml:"name"`
    Age  int    `xml:"age"`
}

func main() {
    person := Person{
        Name: "Alice",
        Age:  30,
    }

    xmlData, err := xml.Marshal(person)
    if err != nil {
        fmt.Println("XML encoding error:", err)
        return
    }

    fmt.Println(string(xmlData))
}
```

在上面的示例代码中，我们定义了一个`Person`结构体，它有两个字段`Name`和`Age`。我们使用`xml`标签来指定字段在XML中的名称。然后，我们创建了一个`Person`对象，并调用`xml.Marshal()`函数将其编码为XML格式的数据。最后，我们使用`fmt.Println()`函数将编码后的XML数据打印出来。

接下来，我们来看一下`xml.Unmarshal()`函数，它用于将XML数据解码为Go数据结构。它的函数签名如下：
```go
func Unmarshal(data []byte, v interface{}) error
```

`data`是要解码的XML数据，`v`是用于存储解码结果的变量，它可以是任意的结构体、切片、映射等。该函数会将解码后的数据存储到`v`中，并返回一个可能出现的错误。

下面是一个示例代码，演示了如何使用`xml.Unmarshal()`函数将XML数据解码为Go结构体：
```go
type Person struct {
    Name string `xml:"name"`
    Age  int    `xml:"age"`
}

func main() {
    xmlData := []byte(`
        <Person>
            <name>Alice</name>
            <age>30</age>
        </Person>
    `)

    var person Person
    err := xml.Unmarshal(xmlData, &person)
    if err != nil {
        fmt.Println("XML decoding error:", err)
        return
    }

    fmt.Println(person.Name, person.Age)
}
```

在上面的示例代码中，我们定义了一个`Person`结构体，它有两个字段`Name`和`Age`。然后，我们创建了一个XML数据，并将其存储在`xmlData`变量中。接下来，我们声明一个`Person`类型的变量`person`，并调用`xml.Unmarshal()`函数将XML数据解码到`person`中。最后，我们使用`fmt.Println()`函数将解码后的数据打印出来。

## 进阶用法

1. 自定义XML标签名称：除了使用结构体字段的名称作为XML元素的标签名称外，我们还可以在结构体字段上使用`xml`标签来指定自定义的标签名称。例如：
   ```go
   type Person struct {
       Name string `xml:"full_name"`
       Age  int    `xml:"age"`
   }
   ```
   在这个例子中，`Name`字段将被编码为`<full_name>`元素，而不是默认的`<Name>`元素。

2. 忽略字段：如果您希望在XML编码或解码时忽略某个结构体字段，可以在字段上使用`xml:"-"`标签。这点上与encoding/json的使用是一致的：
   ```go
   type Person struct {
       Name string `xml:"full_name"`
       Age  int    `xml:"-"`
   }
   ```
   在这个例子中，`Age`字段将被忽略，不会出现在XML中。

3. 嵌套结构体：我们可以在结构体中嵌套其他结构体，以表示更复杂的XML结构：
   ```go
   type Address struct {
       Street  string `xml:"street"`
       City    string `xml:"city"`
       Country string `xml:"country"`
   }

   type Person struct {
       Name    string  `xml:"full_name"`
       Age     int     `xml:"age"`
       Address Address `xml:"address"`
   }
   ```

4. 属性字段：我们可以使用`xml:"attr_name,attr"`标签将结构体字段编码为XML元素的属性。例如：
   ```go
   type Person struct {
       Name string `xml:"full_name"`
       Age  int    `xml:"age,attr"`
   }
   ```
   在这个例子中，`Age`字段将被编码为`<Person age="30">`。

# errors
`import "errors"`

errors包实现了创建错误值的函数。

`errors`包是Go语言标准库中用于错误处理的包，它提供了一些函数和接口，用于创建和处理错误信息。

## 常规使用

在Go语言中，错误通常被表示为一个实现了`error`接口的类型。`errors`包提供了一个简单的函数`New`，用于创建一个新的错误实例。例如：

```go
package main

import (
	"errors"
	"fmt"
)

func divide(x, y int) (int, error) {
	if y == 0 {
		return 0, errors.New("division by zero")
	}
	return x / y, nil
}

func main() {
	result, err := divide(10, 0)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	fmt.Println("Result:", result)
}
```

在上面的例子中，`divide`函数用于计算两个整数的除法。如果除数为0，就会返回一个错误实例，表示除零错误。在`main`函数中，我们调用`divide`函数并检查返回的错误。如果错误不为`nil`，则打印错误信息；否则，打印计算结果。

除了使用`errors.New`函数创建错误实例，我们还可以使用`fmt.Errorf`函数创建带有格式化错误信息的错误。例如：

```go
package main

import (
	"fmt"
)

func divide(x, y int) (int, error) {
	if y == 0 {
		return 0, fmt.Errorf("division by zero: %d / %d", x, y)
	}
	return x / y, nil
}

func main() {
	result, err := divide(10, 0)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	fmt.Println("Result:", result)
}
```

在上面的例子中，我们使用`fmt.Errorf`函数创建了一个带有格式化错误信息的错误实例。这样可以方便地将变量的值包含在错误信息中，以便更好地定位和调试错误。

## 判断函数

`errors`包提供了一些附加的函数和方法，以便在错误判断、转换和展开方面进行更灵活和精确的操作。下面是一些常用的函数和方法：

1. `Is(err, target error) bool`：该函数用于判断错误`err`是否与目标错误`target`相等。它会递归地检查错误链中的每个错误，如果找到匹配的错误，则返回`true`，否则返回`false`。
    
2. `As(err error, target interface{}) bool`：该函数用于将错误`err`转换为目标类型`target`。它会递归地检查错误链中的每个错误，如果找到可以转换为目标类型的错误，则将其赋值给`target`，并返回`true`，否则返回`false`。
    
3. `Unwrap(err error) error`：该函数用于返回错误链中的下一个错误。它返回错误`err`的下一个错误，如果没有下一个错误，则返回`nil`。

这些函数和方法可以帮助我们更好地处理错误。例如，使用`Is`函数可以判断错误类型，根据不同的错误类型采取不同的处理方式。使用`As`函数可以将错误转换为特定的类型，以便进行更详细的错误处理。使用`Unwrap`函数可以展开错误链，以便逐个处理每个错误。

# flag
`import "flag"`

flag包实现了命令行参数的解析。我们可以通过使用flag包来获取命令行中的输入。

使用flag.String(), Bool(), Int()等函数注册flag，下例声明了一个整数flag，解析结果保存在`*int`指针ip里：

```go
import "flag"
var ip = flag.Int("flagname", 1234, "help message for flagname")
```
上面的代码中定义了一个名为flagname的参数，其默认值为1234，显示在控制台的提示信息为"help message for flagname"。

> [!info]
> 参数名称为flagname表明我们可以在命令行使用`-flagname`或是`--flagname`的方式来指定参数的值

如果你喜欢，也可以将flag绑定到一个变量，使用Var系列函数：

```go
var flagvar int
func init() {
	flag.IntVar(&flagvar, "flagname", 1234, "help message for flagname")
}
```
或者你可以自定义一个用于flag的类型（满足Value接口）并将该类型用于flag解析，如下：
```go
flag.Var(&flagVal, "name", "help message for flagname")
```
对这种flag，默认值就是该变量的初始值。

在所有我们需要搜集的flag都注册之后，直接调用：
```go
flag.Parse()
```
来将命令行中的参数解析并写入注册的flag里。

## 简单示例
下面是一个使用flag的简单例子：
```go
package main

import (
	"flag"
	"fmt"
)

func main() {
	// 定义命令行参数
	name := flag.String("name", "Guest", "your name")
	age := flag.Int("age", 0, "your age")

	// 解析命令行参数
	flag.Parse()

	// 输出命令行参数的值
	fmt.Println("Name:", *name)
	fmt.Println("Age:", *age)
}
```

使用下面的命令来为参数赋值：

```sh
go run .\flag\main.go -name coco -age 12
```

解析之后，flag的值可以直接使用。需要注意的是：**如果你使用的是flag自身，它们是指针；如果你绑定到了某个变量，它们是值。**
```go
fmt.Println("ip has value ", *ip)
fmt.Println("flagvar has value ", flagvar)
```

解析后，flag后面的参数可以从flag.Args()里获取或用flag.Arg(i)单独获取。这些参数的索引为从0到flag.NArg()-1。

另一种方式是使用不具名参数，具体的实现如下：

```go
package main

import (
	"flag"
	"fmt"
)

func main() {
	getArgWithoutName()
}

func getArgWithoutName() {
	flag.String("name", "Guest", "your name")
	flag.Int("age", 0, "your age")
	
	flag.Parse()
	
	name := flag.Arg(0)
	age := flag.Arg(1)
	
	fmt.Println("Name:", name)
	fmt.Println("Age:", age)
}
```

这类不具名参数能够通过如下方式赋值：

```sh
go run .\flag\main.go cc 1
```

此时name为cc，age为1

命令行flag语法：
```sh
-flag
-flag=x
-flag x  // 只有非bool类型的flag可以
```

可以使用1个或2个'-'号，效果是一样的。最后一种格式不能用于bool类型的flag，因为如果有文件名为0、false等时,如下命令：
```sh
cmd -x *
```

其含义会改变。你必须使用-flag=false格式来关闭一个bool类型flag。

Flag解析在第一个非flag参数（单个"-"不是flag参数）之前停止，或者在终止符"--"之后停止。

整数flag接受1234、0664、0x1234等类型，也可以是负数。bool类型flag可以是：

`1, 0, t, f, T, F, true, false, TRUE, FALSE, True, False`

时间段flag接受任何合法的可提供给`time.ParseDuration`的输入。

默认的命令行flag集被包水平的函数控制。FlagSet类型允许程序员定义独立的flag集，例如实现命令行界面下的子命令。FlagSet的方法和包水平的函数是非常类似的。

# fmt
`import "fmt"`

mt包实现了类似C语言printf和scanf的格式化I/O。格式化动作（'verb'）源自C语言但更简单。

## 简单示例
下面是`fmt`包的一些基本使用示例：

```go
package main

import "fmt"

func main() {
    name := "Alice"
    age := 25

    // 格式化输出
    fmt.Printf("Name: %s, Age: %d\n", name, age)

    // 格式化字符串
    str := fmt.Sprintf("Name: %s, Age: %d", name, age)
    fmt.Println(str)

    // 格式化输入
    var inputName string
    var inputAge int
    fmt.Print("Enter your name: ")
    fmt.Scanln(&inputName)
    fmt.Print("Enter your age: ")
    fmt.Scanln(&inputAge)
    fmt.Printf("Hello, %s! You are %d years old.\n", inputName, inputAge)
}
```

在上面的代码中，我们使用了`fmt`包的几个常用函数和方法：

1. `fmt.Printf`：用于格式化输出，可以将数据按照指定的格式==输出到标准输出==。在示例中，我们使用`%s`和`%d`作为占位符，分别表示字符串和整数类型，然后通过逗号分隔的方式将变量的值传递给`Printf`函数。

2. `fmt.Sprintf`：用于格式化字符串，将数据按照指定的格式转换为==字符串==。在示例中，我们使用相同的占位符和变量值，但是通过`Sprintf`函数将格式化后的字符串保存到变量`str`中。

3. `fmt.Scanln`：用于格式化输入，从标准输入中读取数据并将其存储到指定的变量中。在示例中，我们使用`Scanln`函数分别读取用户输入的姓名和年龄，并将其存储到`inputName`和`inputAge`变量中。

## 其他常用函数

1. `fmt.Stringer`：`fmt.Stringer`是一个接口，用于定义自定义类型的字符串表示形式。该函数的整体使用类似于Java中的`toString()`方法。如果一个类型实现了`String() string`方法，它就满足了`fmt.Stringer`接口的要求。`fmt`包中的函数如`fmt.Println`和`fmt.Printf`会==自动调用==这个方法来打印自定义类型的字符串表示形式。

   例如，我们可以定义一个自定义类型`Person`，并实现`String() string`方法来返回该类型的字符串表示形式：

   ```go
   type Person struct {
       Name string
       Age  int
   }

   func (p Person) String() string {
       return fmt.Sprintf("Name: %s, Age: %d", p.Name, p.Age)
   }

   func main() {
       person := Person{Name: "Alice", Age: 25}
       fmt.Println(person) // 输出：Name: Alice, Age: 25
   }
   ```

2. `fmt.Scanf`：`fmt.Scanf`函数用于从标准输入中读取格式化的数据，并将其存储到传入的变量中。它的使用方式类似于`fmt.Printf`，但是它会根据格式字符串解析输入并将解析结果存储到对应的变量中。

   例如，我们可以使用`fmt.Scanf`读取用户输入的姓名和年龄，并将其存储到相应的变量中：

   ```go
   var name string
   var age int
   fmt.Println("请输入姓名和年龄：")
   fmt.Scanf("%s %d", &name, &age)
   fmt.Printf("姓名：%s，年龄：%d\n", name, age)
   ```

   用户输入的内容将根据`%s`和`%d`的格式进行解析，并存储到`name`和`age`变量中。

3. `fmt.Sscan`：`fmt.Sscan`函数类似于`fmt.Scanf`，但是它可以从字符串中读取格式化的数据，并将其存储到传入的变量中。它的使用方式和`fmt.Scanf`类似，只是它从字符串中读取数据而不是从标准输入中读取。

   例如，我们可以使用`fmt.Sscan`从字符串中读取姓名和年龄，并将其存储到相应的变量中：

   ```go
   var name string
   var age int
   input := "Alice 25"
   fmt.Sscan(input, &name, &age)
   fmt.Printf("姓名：%s，年龄：%d\n", name, age)
   ```

   字符串`"Alice 25"`将根据空格分隔，并将解析结果存储到`name`和`age`变量中。

这些函数和接口是`fmt`包中常用的一部分，用于格式化输入和输出。它们提供了灵活的方式来处理字符串和标准输入输出，使得代码更加可读和易于维护。

## verb：

通用：
```
%v	值的默认格式表示
%+v	类似%v，但输出结构体时会添加字段名
%#v	值的Go语法表示
%T	值的类型的Go语法表示
%%	百分号
```

布尔值：
```
%t	单词true或false
```

整数：
```
%b	表示为二进制
%c	该值对应的unicode码值
%d	表示为十进制
%o	表示为八进制
%q	该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示
%x	表示为十六进制，使用a-f
%X	表示为十六进制，使用A-F
%U	表示为Unicode格式：U+1234，等价于"U+%04X"
```
更多的verb与API说明详见：
https://studygolang.com/pkgdoc

# io
`import "io"`

io包提供了对I/O原语的基本接口。本包的基本任务是包装这些原语已有的实现（如os包里的原语），使之成为共享的公共接口，这些公共接口抽象出了泛用的函数并附加了一些相关的原语的操作。

因为这些接口和原语是对底层实现完全不同的低水平操作的包装，除非得到其它方面的通知，客户端不应假设它们是并发执行安全的。

## 常用接口

- Reader : 读取文件中的数据到字节数组中
- Writer : 将字节数组的数据写入到文件中
- Closer : 用于关闭连接
- Seeker : 给定 whence 和 offset，计算得出新的offset，用于在特定位置开始读写

可以看到 Reader 和 Writer 接口中定义的方法中，都有字节数组p，而底层要操作的文件在方法中都没有体现。Read方法是将文件的数据读入字节数组p，Write 是将字节数组p的数据写入文件，这一点不要记混。

### Reader

io.Reader接口定义了 `Read` 方法，用于读取数据到==字节数组==中：

- 入参：字节数组 p，会将数据读入到 p 中
- 返回值：本次读取的字节数 n，以及遇到的错误 err
```
type Reader interface {    Read(p []byte) (n int, err error)   }   
```
**方法功能详解**

1. 方法读取数据写入到字节数组 p 中，由于 p 是有大小的，所以一次至多读取 len(p) 个字节
2. 方法返回读取的数据字节数 n(0 <= n <= len(p))，以及读取过程中遇到的 error
3. 即使一次调用读取到的数据小于 len(p)，也可能会占用整个字节数组 p 作为暂存空间
4. 如果数据源的数据量小于 len(p) 个字节，方法只会读取当前可用数据，不会等待更多数据的到来

**何时返回error**

1. 在成功读取了 n（n>0）个字节后，如果产生了 error 或者 读到文件末尾 （end-of-file），本次调用必须要返回读取的字节数 n，但对于err 的值，可以选择在本次直接返回 err（err!=nil），或者在下次调用的时候再返回 err (n=0, err!=nil)。常见的一个例子就是，读取到n个字节后到达文件末尾（EOF），此时可以返回 err=EOF 或者 err=nil，下次调用返回 n=0,err=EOF。
2. 调用者需要注意，每次调用后，如果 n>0，应该先处理数据，再考虑 err 是否为 nil。因为上一点已经指出，如果读取到 n>0 个字节后遇到 error，会同时返回 n>0 和 err!=nil，此时就需要先处理数据再考虑 err。

**方法实现和调用需注意**

1. 如果想要实现该方法，不推荐同时返回 n=0 和 err=nil，除非 len(p)=0
2. 如果调用该该方法返回 n=0 和 err=nil，可以认为什么都没有发生，不能认为是读到文件末尾了（end-of-file）
3. 实现该方法后，一定不要持有字节数组p （保留下地址做他用）

### Writer
io.Writer接口定义了 `Write` 方法，用于写数据到文件中

- 入参：字节数组 p，会将 p 中的数据写入到文件中
- 返回值：成功写入完成的字节数 n，以及遇到的错误 err

```go
type Writer interface {    
	Write(p []byte) (n int, err error)   
}   
```
**方法功能详解**

1. 该方法将 p 中的数据写到文件中
2. 方法返回成功写入的字节数 n（0 <= n <= len(p)），以及写入过程中遇到的错误 err
3. 如果 n<len(p)，方法必须返回 err!=nil
4. 方法一定不能修改字节数组 p，即使是临时修改也不被允许

**方法实现需注意**

1. 实现该方法后，一定不要持有字节数组p，只是用来读取数据

### Closer

io.Closer接口定义了 `Close` 方法，该方法用于关闭连接。

**方法实现需注意**
第一次调用该方法后，再次调用该方法应该产生什么行为，该接口没有定义，依赖实现方法自定义。

```go
type Closer interface {    
	Close() error 
}
```

### Seeker

io.Seeker接口定义了 `Seek` 方法，该方法用于指定下次读取或者写入时的偏移量

- 入参：计算新偏移量的起始值 whence， 基于whence的偏移量offset
- 返回值：基于 whence 和 offset 计算后新的偏移量值，以及可能产生的错误

```go
type Seeker interface {    
	Seek(offset int64, whence int) (ret int64, err error)   
}   
```

**方法功能详解**

1. io包中定义了如下三种 whence
```go
    const (    
    SeekStart   = 0 // 基于文件开始位置    
    SeekCurrent = 1 // 基于当前偏移量     
    SeekEnd     = 2 // 基于文件结束位置   ) 
 ```
    
2. 如果计算后新的偏移量，在文件起始位置之前，返回 error!=nil
    
3. 任意正数的偏移量都是合法的，但是对数据源如何进行I/O操作，依赖具体的实现方法


在Go语言中，`Seek`函数用于在文件中定位指定的偏移量。它的函数签名如下：

```go
func (f *File) Seek(offset int64, whence int) (ret int64, err error)
```

`Seek`函数有两个参数：`offset`和`whence`，以及两个返回值：`ret`和`err`。

- `offset`表示要定位的偏移量，可以是正数、负数或零。正数表示向文件尾部移动，负数表示向文件起始位置移动，零表示不移动。
- `whence`表示定位的基准位置，可以是以下三个常量之一：
  - `io.SeekStart`：相对于文件起始位置。
  - `io.SeekCurrent`：相对于当前位置。
  - `io.SeekEnd`：相对于文件尾部。

`ret`表示定位后的偏移量，`err`表示定位过程中是否发生了错误。

下面是一个示例代码，我们可以用[[常用标准库#os]] os包中的Seek和Read函数实现对于文件的读取：

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	file, err := os.Open("data.txt")
	if err != nil {
		fmt.Println("Failed to open file:", err)
		return
	}
	defer file.Close()

	_, err = file.Seek(10, 0) // 从文件起始位置向后移动10个字节
	if err != nil {
		fmt.Println("Failed to seek:", err)
		return
	}

	buffer := make([]byte, 5) // 创建一个5个字节的切片
	_, err = file.Read(buffer)
	if err != nil {
		fmt.Println("Failed to read:", err)
		return
	}

	fmt.Println(string(buffer))
}
```

在上面的代码中，我们首先打开一个名为"data.txt"的文件。然后，我们使用`Seek`函数将文件指针从起始位置向后移动10个字节。接下来，我们创建一个长度为5的字节切片，并使用`Read`函数从文件中读取5个字节的数据到该切片中。最后，我们将读取到的数据转换为字符串并打印出来。

如果你有仔细阅读上面的代码，可能已经发现了一个问题：使用了Seek函数确定了文件读取的偏移量之后，我们并没有使用任何对应的变量来接受对应的偏移量，那Read函数是如何知道应该从哪里读取文件的呢？

这个问题的关键点在于文件偏移量的存储，在我们使用的os包中，golang为了简化对应的开发流程，为我们使用os.File对操作系统文件描述符(File Descriptor)进行了封装。Seek方法调用了syscall包的seek函数,该函数将偏移量写入了操作系统的文件描述符状态。

当后续调用os的Read方法时,由于它是直接调用操作系统的read去实际读取,所以就会从该偏移量位置开始读。

也就是说,文件偏移量是由操作系统内核维护的,存放在文件描述符的状态元数据中。os.File只是对该状态的一个包装。同时，这个os.File我们可以将其理解为单例，在应用运行期间，我们各个goroutine对文件的调用都能获取到同步的文件信息，包括对应的文件偏移量。

## 组合接口

在go语言中，可以利用接口的组合，来囊括其他接口中的方法，类似于定义了一个父接口，可以包含多个子接口。如果一个 struct 实现了所有子接口的方法，也就相当于实现了父接口。`小接口` + `接口组合`的方式，很大程度上增加了程序的灵活性，在我们自己业务开发过程中，可以借鉴这种做法。

针对上面四个最小粒度的接口，io包定义了如下几种组合接口：

```go
// ReadWriter 是 Read 和 Write 方法的组合
type ReadWriter interface {
    Reader
    Writer
}

// ReadCloser 是 Read 和 Close 方法的组合
type ReadCloser interface {
    Reader
    Closer
}

// WriteCloser 是 Write 和 Close 方法的组合
type WriteCloser interface {
    Writer
    Closer
}

// ReadWriteCloser 是 Read、Write 和 Close 方法的组合
type ReadWriteCloser interface {
    Reader
    Writer
    Closer
}

// ReadSeeker 是 Read 和 Seek 方法的组合
type ReadSeeker interface {
    Reader
    Seeker
}

// WriteSeeker 是 Write 和 Seek 方法的组合
type WriteSeeker interface {
    Writer
    Seeker
}

// ReadWriteSeeker 是 Read、Write 和 Seek 方法的组合
type ReadWriteSeeker interface {
    Reader
    Writer
    Seeker
}
```

## 其他接口

- ReaderFrom: 定义了 ReadFrom 方法，从 Reader 中读取数据
- WriterTo: 定义了 WriteTo 方法，向 Writer 中写入数据
- ReaderAt: 定义了 ReadAt 方法，从指定位置读取数据
- WriterAt: 定义了 WriteAt 方法，从指定位置写入数据
- ByteReader: 定义了 ReadByte 方法，读取一个字节
- ByteScanner: 组合接口，除了ReadByte 方法，定义了 UnreadByte 方法，用于回退一个字节
- ByteWriter： 定义了 WriteByte 方法，向文件写入一个字节
- RuneReader: 定义了 ReadRune 方法，读取一个 UTF-8 字符
- RuneScanner: 组合接口，除了 ReadRune 方法，定义了 UnreadRune 方法，用于回退一个 rune
- StringWriter: 定义了 WriteString 方法，用于向文件写入一个字符串

## 参考文章
[Go语言 io包核心接口详解 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzU5NzU2NDk2MA==&mid=2247484833&idx=1&sn=131de4fb02ed7291c18f790c89297b67&chksm=fe50ceeec92747f88cfa292939f679e21d355ab5241e6ef08cec865b5bec7a90bbea58cafaba&scene=21#wechat_redirect)
[Go语言 io包基本接口详解 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/448362383)

---

# ioutil

`import "io/ioutil"`

> 自1.16版本开始，官方已经不再推荐使用ioutil包进行开发


上文我们提到了io包中的一些常用接口，而针对于这些接口，golang提供了一些接口的常用实现的封装，并将这些函数放到单独的ioutil包中以实现便捷调用。

需要注意的是，该包在实际业务场景中只适用于读小文件，因为里面的函数都是一次性将所有内容读入内存，如果需要实现缓冲区，对应的方法可见`bufio`包。

ioutil中的常用方法如下：

|方法名| 描述|
|-|-|
|`NopCloser` |对`Reader`进行封装，返回一个`ReadCloser` |
|`ReadAll` |对 `Reader` 进行读取， 直到发生错误或者遇到 `EOF` 为止， 然后返回被读取的数据。|
|`ReadFile`| 读取指定文件的内容，并返回。|
|`ReadDir` |读取 指定的目录， 并返回排序后的目录列表(根据名称排序)|
|`TempDir` |在指定目录新创建一个临时目录， 并返回该目录的路径 |
|`TempFile` |在指定目录新创建一个临时文件， 以可读写的方式打开它， 并返回 `*os.File` 指针|
|`WriteFile` |将给定的数据 写入到指定文件里面。|

如果文件不存在， 则去创建它；  
如果文件已经存在， 则再写入之前会先清空文件中已有的内容。



## 方法介绍

### readAll
readAll 是一个==内部方法==，从入参 reader 中读取全部数据，然后返回读取到的数据以及产生的 error，主要是调用 butes.Buffer 的 ReadFrom 方法（读取完数据产生的EOF error 在这里不算做 error，因为目的就是读取完数据）。

```go
// io.Reader r : 保存着底层数据，数据从 r 中读取
// capacity： 用于设置保存数据的字节缓冲区的初始容量，但是在读取过程中会自动扩容的

func readAll(r io.Reader, capacity int64) (b []byte, err error) {
	var buf bytes.Buffer

	// 如果字节缓冲区在读取过程中一直扩容，最终超出了系统设置的最大容量，会产生 ErrTooLarge panic，在这里捕获，改为返回一个 error
	// 如果是其他类型的 panic，保持 panic
	defer func() {
		e := recover()
		if e == nil {
			return
		}
		if panicErr, ok := e.(error); ok && panicErr == bytes.ErrTooLarge {
			err = panicErr
		} else {
			panic(e)
		}
	}()

	// 设置默认容量
	if int64(int(capacity)) == capacity {
		buf.Grow(int(capacity))
	}

	// 读取数据
	_, err = buf.ReadFrom(r)
	return buf.Bytes(), err
}

```

### ReadAll

```go
func ReadAll(r io.Reader) ([]byte, error) 
```

比较常用的工具类方法，一次性读取文件的所有内容并返回，适用于读取小文件，如果文件太大会占用太多内存。调用 ReadAll 方法成功，会读取` io.Reader r `的所有内容，返回的 `err == nil`，而不是 `err == EOF`，因为读取完所有数据了，完成了我们的任务，此时 EOF 不应当是 error。

代码示例：
```go
func main() {
	file, err := os.Open("test.txt")
	if err != nil {
		fmt.Println("open file err")
		return
	}

	c, err := ioutil.ReadAll(file)
	fmt.Println(err)
	fmt.Println(string(c))
}
```

类似的，我们也可以对一个reader进行`readAll`：
```go
func main() {
    // NewReader创建一个从s读取数据的Reader。本函数类似bytes.NewBufferString
    reader := strings.NewReader("Hello word !")
    all, err := ioutil.ReadAll(reader)
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Printf("%s\n",all)
}
// 输出: Hello word !
```


### ReadFile

```go
func ReadFile(filename string) ([]byte, error) 
```

ReadFile 根据文件名读取文件，返回文件的所有内容以及读取过程中产生的error，与ReadAll类似，读取完文件后，EOF 不算做 error，因为已经完成了任务。

使用示例：

```go
func main() {
   // 文件路径
   fileName := "./test.log"
   data, err := ioutil.ReadFile(fileName)
   if err != nil {
      fmt.Println(err)
      return
   }
   fmt.Printf("%s\n",data)
}
```

### WriteFile
```go
func WriteFile(filename string, data []byte, perm os.FileMode) error
```

函数向`filename`指定的文件中写入数据。

- 如果文件不存在,将按给出的权限创建文件，
- 如果文件存在,在写入数据之前==清空==文件。

代码示例：
```go
func main() {
    fileName := "./test.txt"
    for i := 0; i < 3; i++ {
        _ = ioutil.WriteFile(fileName, []byte("Hello World!"), os.ModePerm)
    }
    fmt.Println("end")
}
```

上面的`os.ModePerm`为文件的权限，我们可以使用os包中定义的常量来设置文件的权限，`os.ModePerm`表示文件的读写权限

```go
func main() {

	var buffer bytes.Buffer
	
	for i := 0; i < 100; i++ {
		buffer.WriteString("this is line " + fmt.Sprintf("%d", i) + "\n")
	}
	if err := ioutil.WriteFile("testFile", buffer.Bytes(), 0644); err != nil {
		fmt.Println(err)
	}
}

```

对应的源码：
```go
// filename指定了文件名，data是要写入的数据，perm 指定了文件权限（如 0644）
func WriteFile(filename string, data []byte, perm os.FileMode) error {
	// 调用os.OpenFile 方法创建打开文件
	f, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, perm)
	if err != nil {
		return err
	}
	// 写入数据
	_, err = f.Write(data)
	if err1 := f.Close(); err == nil {
		err = err1
	}
	return err
}
```

### ReadDir
```go
func ReadDir(dirname string) ([]os.FileInfo, error) 
```

ReadDir 用于获取文件夹下面的所有文件信息(文件夹+文件)，返回的数据是文件名有序的（只输出单层，文件夹下的文件不会输出）
```GO
func main() {
	fileList, err := ioutil.ReadDir("ioutil")
	fmt.Println("\nfolder information:")
	for _, f := range fileList {
		fmt.Println(f.Name(), f.IsDir())
	}
	fmt.Println(err)
}

/*
1.log false
composetest true
hello.sh false
student.txt false
wordpress true
<nil>
 */
```

对应的源码：
```go
func ReadDir(dirname string) ([]os.FileInfo, error) {
	f, err := os.Open(dirname)
	if err != nil {
		return nil, err
	}
	list, err := f.Readdir(-1)
	f.Close()
	if err != nil {
		return nil, err
	}
	sort.Slice(list, func(i, j int) bool { return list[i].Name() < list[j].Name() })
	return list, nil
}
```

### nopCloser

`nopCloser` 的作用是将一个 io.Reader 类型包装成为了 io.ReadCloser 类型, 实现了 Close() 方法，但什么也没做，只是返回了 nil。

**使用示例**
在我们需要将一个 io.Reader 类型包装成 io.ReadCloser 类型时，可以直接调用该方法，比如Go 原生的 http NewRequestWithContext 方法，就直接使用了该方法：

```go
func NewRequestWithContext(ctx context.Context, method, url string, body io.Reader) (*Request, error) {
	
  ......
  
  // 传入的 body 是 io.Reader 类型，如果不是 io.ReadCloser 类型，调用 ioutil.NopCloser 转一下
	rc, ok := body.(io.ReadCloser)
	if !ok && body != nil {
		rc = ioutil.NopCloser(body)
	}
  
  .......
}
```

对应源码：

```go
type nopCloser struct {
	io.Reader
}

func (nopCloser) Close() error { return nil }

// NopCloser 传入一个 io.Reader 类型，返回 io.ReadCloser 类型
func NopCloser(r io.Reader) io.ReadCloser {
	return nopCloser{r}
}

```

### Discard

Discard 如名字一样，是一个用于丢弃数据的地方，虽然有时候我们不在意数据内容，但可能存在数据不读出来就无法关闭连接的情况，这时候就可以使用 io.Copy(ioutil.Discard, io.Reader) 将数据写入 Discard。Discard 是 io.Writer 类型，是通过 devNull 定义得来的，devNull 实现了 Write 方法（其实什么都没做，直接返回长度，永远成功）

使用示例：
Go 原生 http 包，server.go 就使用了 io.Copy(ioutil.Discard, mb)

```go
func (globalOptionsHandler) ServeHTTP(w ResponseWriter, r *Request) {
	w.Header().Set("Content-Length", "0")
	if r.ContentLength != 0 {
		// Read up to 4KB of OPTIONS body (as mentioned in the
		// spec as being reserved for future use), but anything
		// over that is considered a waste of server resources
		// (or an attack) and we abort and close the connection,
		// courtesy of MaxBytesReader's EOF behavior.
		mb := MaxBytesReader(w, r.Body, 4<<10)
		io.Copy(ioutil.Discard, mb)
	}
}
```

对应源码：
```go
var Discard io.Writer = devNull(0)

type devNull int

var _ io.ReaderFrom = devNull(0)

// 实现了 Write 方法，什么也不做，直接返回长度
func (devNull) Write(p []byte) (int, error) {
	return len(p), nil
}

// 实现了 WriteString 方法，什么也不做，直接返回长度

func (devNull) WriteString(s string) (int, error) {
	return len(s), nil
}

// sync.Pool 用来做变量复用的，因为我们根本不在意数据内容，只是为了将数据读出来，
// 为了减少内存分配，提高读取时的字节切片复用程度，使用了 sync.Pool，它就像一个黑洞，丢数据进去就行

var blackHolePool = sync.Pool{
	New: func() interface{} {
		b := make([]byte, 8192)
		return &b
	},
}

// 从 blackHolePool 中获取字节切片 bufp ， 将 io.Reader 的数据读入 bufp，
// 然后再将 bufp 丢入 blackHolePool，如此往复，只使用了一个变量
func (devNull) ReadFrom(r io.Reader) (n int64, err error) {
	bufp := blackHolePool.Get().(*[]byte)
	readSize := 0
	for {
		readSize, err = r.Read(*bufp)
		n += int64(readSize)
		if err != nil {
			blackHolePool.Put(bufp)
			if err == io.EOF {
				return n, nil
			}
			return
		}
	}
}
```

### TempDir
```go
func TempDir(dir, pattern string) (name string, err error)
```

在`dir`目录里创建一个新的、使用`pattern`作为前缀的临时文件夹，并返回文件夹的路径。

- 如果`dir`是空字符串，`TempDir`使用默认用于临时文件的目录。
- 不同程序同时调用该函数会创建不同的临时目录，
- 创建的临时文件夹时在不使用时，需要删除。

  ```go
func main() {
    var pathList []string
    for i := 0; i < 4; i++ {
        var path string
        var err error
        switch i {
        case 0:
            // 指定目录和前缀
            path, err = ioutil.TempDir("./log","tmp_")
        case 1:
            // 只指定目录
            path, err = ioutil.TempDir("./log","")
        case 2:
            // 目录为空、前缀不为空
            path, err = ioutil.TempDir("","tmp_")
        case 3:
            // 目录和前缀都是空
            path, err = ioutil.TempDir("","")
        }
        if err != nil {
            fmt.Println(err)
            continue
        }
        pathList = append(pathList, path)
    // 删除临时目录,测试时注释
        // _ = os.RemoveAll(path)
    }
    fmt.Println(pathList)
}
/**输出
log/tmp_984088491
log/346734350 
/var/folders/8f/vnx2y1h57nzbd2p4vtcl6hv80000gn/T/tmp_561537301 /var/folders/8f/vnx2y1h57nzbd2p4vtcl6hv80000gn/T/840593776]
*/
```

### TempFile
```go
func TempFile(dir, pattern string) (f *os.File, err error)
```

在`dir`目录下创建一个新的、使用`pattern`为前缀的临时文件，以读写模式打开该文件并返回`os.File`指针。

- 如果`dir`是空字符串，`TempFile`使用默认用于临时文件的目录。
- 不同程序同时调用该函数会创建不同的临时文件。
- 创建的临时文件夹时在不使用时，需要删除。

代码示例：

```go
func main() {
    var fileList []string
    for i := 0; i < 4; i++ {
        var file *os.File
        var err error
        switch i {
        case 0:
            // 指定目录和前缀
            file, err = ioutil.TempFile("./log", "tmp_")
        case 1:
            // 只指定目录
            file, err = ioutil.TempFile("./log", "")
        case 2:
            // 目录为空、前缀不为空
            file, err = ioutil.TempFile("", "tmp_")
        case 3:
            // 目录和前缀都是空
            file, err = ioutil.TempFile("", "")
        }
        if err != nil {
            fmt.Println(err)
            continue
        }
        fileList = append(fileList, file.Name())
        //删除
        //_ = os.Remove(file.Name())
    }
    fmt.Println(fileList)
}
/**输出
[log/tmp_598309912 log/983448727 /var/folders/8f/vnx2y1h57nzbd2p4vtcl6hv80000gn/T/tmp_134984970 /var/folders/8f/vnx2y1h57nzbd2p4vtcl6hv80000gn/T/246937825]
*/
```
## 参考文章

[(18条消息) Go语言ioutil包详解_go ioutil_Lifelmy的博客-CSDN博客](https://blog.csdn.net/u012948302/article/details/123267758)
[go包：ioutil(IO操作函数集) - 简书 (jianshu.com)](https://www.jianshu.com/p/7e132ae53e1f)

---

# log

golang内置了log包，实现简单的日志服务。通过调用log包的函数，可以实现简单的日志打印功能。

log包中有3个系列的日志打印函数，分别print系列、panic系列、fatal系列。

函数系列 作用
`print` 单纯打印日志
`panic` 打印日志，抛出panic异常
`fatal` 打印日志，强制结束程序(os.Exit(1))，defer函数不会执行
下面是一个简单的日志输出例子：
```go
package main

import (
	"log"
)

func main() {
	log.Print("This is a log message")
	log.Printf("This is a formatted log message: %s", "Hello, World!")
	log.Println("This is a log message with a newline")

	log.Fatal("This is a fatal error log message")
	log.Fatalf("This is a formatted fatal error log message: %s", "Hello, World!")
	log.Fatalln("This is a fatal error log message with a newline")

	log.Panic("This is a panic log message")
	log.Panicf("This is a formatted panic log message: %s", "Hello, World!")
	log.Panicln("This is a panic log message with a newline")
}
```

> [!info]
> 需要注意的是，`log.Fatal`在记录日志后主动退出程序，而`log.Panic`记录日志后会`panic`,可以由`defer recover`捕获。所以上文的程序在执行完`log.Fatal("This is a fatal error log message)"`后就将退出。如果我们希望在记录日志后继续执行其他语句,应该使用log.Panic系列而不是log.Fatal。

总结一下：

- log.Print - 记录日志但不退出程序
- log.Fatal - 记录日志后退出程序
- log.Panic - 记录日志后panic,可以recover

## 设置日志前缀

有时候为了了解错误来源的模块，我们可以对日志设置对应的前缀：
```go
log.SetPrefix("[prefix]")
log.Printf("hello world")

//[prefix]2023/07/27 13:42:56 hello world
```

## 设置日志级别

在记录日志时，有时候只需要记录一些较为重要的信息，而不需要记录所有的日志信息。因此，设置日志级别是非常有必要的。

在Go语言中，标准库中提供了log包，但是并没有提供设置日志级别的函数。一般来说，我们可以自定义一个log包，通过封装log包中的函数，来实现设置日志级别的功能。

下面是一个简单的实现方式：

```go
package main

import (
    "log"
)
func main() {
	//设置日志输出层级为LevelInfo，小于该层级的日志皆不输出
	SetLogLevel(LevelInfo)

	Log(LevelDebug, "debug")
	Log(LevelInfo, "info")
	Log(LevelWarn, "warn")

	//设置日志输出层级为LevelWarn，小于该层级的日志皆不输出
	SetLogLevel(LevelWarn)

	Log(LevelDebug, "debug")
	Log(LevelInfo, "info")
	Log(LevelWarn, "warn")
}

const (
	LevelDebug = iota
	LevelInfo
	LevelWarn
	LevelError
	LevelFatal
)

//初始化globalLogLevel参数，避免空值
var globalLogLevel = LevelInfo

// 封装日志输出函数
func Log(level int, v ...any) {
	if level >= globalLogLevel {
		log.Println(v...)
	}
}

// 设置日志输出级别函数
func SetLogLevel(level int) {
	globalLogLevel = level
}
```

通过自定义Debug、Info、Warn、Error、Fatal函数，我们可以实现在日志级别比设置的级别高时，输出日志信息。

## 定义日志的输出格式

flags是一个用于控制日志输出格式的选项。它是log包中的一个全局变量，定义在log.go文件中，具体定义如下：

```go
const (
    Ldate         = 1 << iota     // 日期：2009/01/23
    Ltime                         // 时间：01:23:23
    Lmicroseconds                 // 微秒级时间：01:23:23.123123
    Llongfile                     // 完整文件名和行号：/a/b/c/d.go:23
    Lshortfile                    // 文件名和行号：d.go:23
    LUTC                          // 使用UTC时间
    LstdFlags     = Ldate | Ltime // 标准格式：2009/01/23 01:23:23
)
```

这些flags常量可以通过log包的SetFlags函数设置，用于指定日志输出的格式。例如，通过设置`log.SetFlags(log.Ldate | log.Ltime)`，可以将日志的格式设置为标准格式，包括日期和时间。

在默认情况下，log包的flags被设置为LstdFlags，即标准格式。你也可以使用log包的Flags函数获取当前的flags值。

需要注意的是，log包的flags是全局共享的，所以对flags的修改会影响到所有使用log包的地方。

## 将日志输出到文件中

在日常的维护中，日志基本会输出到文件中，对上文的日志输出函数稍加改造，我们就可以将日志输出到某一指定的文件中：

```go
// 封装日志输出函数
func Log(level int, v ...any) {
	if level >= globalLogLevel {
		f, _ := os.OpenFile("log.txt", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
		defer f.Close()
		fmt.Fprintln(f, v)
	}
}
```

通过函数的配合，我们也同样能够令不同层级的日志输出到不同的文件中，实现归类。但实际开发中，我们可以使用logrus、zap、zerolog等日志框架来进行更方便的日志使用。

## 参考文章

[go语言log用法有哪些-常见问题-PHP中文网](https://www.php.cn/faq/559342.html)

---

# net/http

`import "net/http"`

http包提供了HTTP客户端和服务端的实现。

Get、Head、Post和PostForm函数发出HTTP/ HTTPS请求。

## 简单示例

**Talk is cheap, show me the code.**

在具体了解这个包之前，我们先来看一个使用net/http包实现的简单的服务器实现：

```go
// 一个处理请求的handler
func hello(w http.ResponseWriter, r *http.Request) {
    fmt.Fprint(w, "Hello World!") 
}

func main() {
    // 创建一个默认的路由
    mux := http.NewServeMux()
    // 为路径挂载对应的处理器
    mux.HandleFunc("/hello", hello)

    // 创建服务器，指定对应的端口和处理路由
    server := &http.Server{
        Addr:    ":8080",
        Handler: mux,
    }

    // 启动服务 
    err := server.ListenAndServe()
    if err != nil {
        log.Fatal(err)
    }
}
```

通过gorun语句开启对应的服务之后，我们可以直接使用如下语句查看服务是否成功搭建：

```cmd
C:\Users\Lenovo>curl localhost:8080/hello                                            
Hello World!
```


如果觉得不太直观的话，我们也可以使用浏览器访问对应的网址或是使用golang语句访问服务：
```go
resp, err := http.Get("http://localhost:8080/hello")
```


通过上面的示例，我们可以了解使用net/http创建一个基础的网络服务只需要以下几步：
1. 创建一个处理请求的handler
2. 针对进入服务的请求，我们需要创建一个路由`mux`，并对其进行配置以便将不同路径的请求分发给不同的handler
3. 创建服务器，指定服务器的创建端口与对应使用的路由`mux`
4. 执行服务器的`ListenAndServe()`方法，开始进行监听，服务启动。

接下来我们针对这几个概念进行一一讲解。


## handler

handler的作用是==对请求进行处理==,并通过ResponseWriter编写响应返回。
handler的设计思想就是做到解耦和可扩展，所以任何类型的对象都可以作为handler，在golang中具体体现为：handler可以为任何实现了ServeHTTP接口的对象：

ServeHTTP接口的签名如下：
```go
ServeHTTP(w http.ResponseWriter, r *http.Request)
```

最简单的handler可以是一个入参与ServeHTTP接口一致的函数：
```go
func myHandler(w http.ResponseWriter, r *http.Request) {
  // 处理请求逻辑
}
```
而对于复杂的handler，我们可以定义struct类型：
```go
type MyHandler struct {}

func (h *MyHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
  // handler逻辑 
}
```
在实际业务中，最好记得handler的如下特性：
1. 一个handler可以包含其它handler,通过组合扩展功能。
2. handler也可以实现==中间件模式==，形成处理链。

### 调用其他handler
有一个通常的业务场景是:

1. 单独定义一个handler处理某个API
2. 在主handler中,根据需要调用对应的API handler

假设我们现在有两种API:
```go
// API1 handler 
func API1Handler(w http.ResponseWriter, r *http.Request) {
    // 业务逻辑
    w.Write([]byte("api1"))
}

// API2 handler
func API2Handler(w http.ResponseWriter, r *http.Request) {
    // 业务逻辑
    w.Write([]byte("api2"))
}
```

然后定义一个主handler:
```go
func MainHandler(w http.ResponseWriter, r *http.Request) {
    switch r.URL.Path {
    case "/api1":
        API1Handler(w, r)    
    case "/api2":
        API2Handler(w, r)
    }   
}

// 注册主handler    
http.HandleFunc("/", MainHandler)
```

主handler 根据请求路径,调用对应的API handler,来处理请求。这样我们就可以将不同API分解成独立的handler,然后在主handler中组合使用。

具体调用方式很简单，直接调用handler,传入相同的参数(ResponseWriter和Request)即可。

需要注意的是，如非必要，不建议这样分发请求，因为设计上请求分发应当是mux进行的，handler最好专注于请求的处理。一般我们通常利用这个方式来实现中间件特性。

### 中间件模式

我们可以通过类似于链式调用的方式来实现handler的中间件模式。

现在假设我们实现了一个日志中间件和一个CORS中间件：

```go
// 日志中间件
func Logger(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 记录请求信息
        log.Println(r.Method, r.URL.Path)
        
        // 调用下一个handler
        next.ServeHTTP(w, r)
    })
}

// CORS中间件
func CORS(next http.Handler) http.Handler { 
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Access-Control-Allow-Origin", "*")
        
        // 调用下一个handler
        next.ServeHTTP(w, r)
    })
}
```

然后还有实际的业务逻辑handler，那么实际的调用可能如下：

```go
func UserHandler() http.Handler { 
    handler := http.HandlerFunc(...)
    
    handler = Logger(handler)
    handler = CORS(handler)
    
    return handler
}

func main() {
    mux := http.NewServeMux()
    
    mux.Handle("/user", UserHandler())
    
    http.ListenAndServe(":8080", mux)
}
```

中间件的本质就是一个入参和出参都为http.Handler的函数，类似于代理模式。

请注意一个请求进入之后实际的执行顺序，我们在Logger中间件和CORS中间件中都将入参称作next，然后首先执行自己的逻辑，执行完毕之后再执行next中的`ServeHTTP()`函数，这意味着在上文的实际调用代码中，请求的执行顺序是从后往前的，也就是先执行CORS中间件再执行Logger中间件，这点在实际开发中需要注意。

### 处理复杂请求

对于一些传入文件的请求，我们可以使用如下方式来处理

```go
// 一个结构体handler用来处理请求
type AppHandler struct {
  // 存储其他信息
  info map[string]string 
}

func (h *AppHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {

  // 使用自定义函数来获取其他信息
  h.info = getInfo() 
  
  // 写入其他信息
  writeInfo(w, h.info)

  // 使用自定义函数来获取文件内容 
  fileContent := getFile()

  // 写入文件头
  w.Header().Set("Content-Type", "application/octet-stream")
  w.Header().Set("Content-Disposition", "attachment; filename=data.bin")

  // 将文件内容写出
  w.Write(fileContent)

}

func main() {
  handler := &AppHandler{make(map[string]string)}
  http.Handle("/", handler)
  http.ListenAndServe(":8080", nil)
}
```

## mux

mux(多路复用器)在net/http包中的作用是将请求分发到相应的handler进行处理。它的本质可以理解为一个请求路由器。

关于mux的使用和本质可以总结几点:

1. mux本质上是一个http.ServeMux结构体对象,用于注册路由规则和handler。
    
2. 使用http.NewServeMux()创建mux实例。
    
3. 使用mux.HandleFunc()注册路由和handler的映射关系。
    
4. mux实现了http.Handler接口，可以作为服务器的Handler使用。
    
5. 接收请求后，mux会根据注册的规则找到匹配的路由,调用对应的handler。
    
6. mux内部使用一个map存储路由与handler的映射表。
    
7. 匹配路由时,会遍历这个map,寻找能够匹配的路由+方法。
    
8. 如果没有匹配的路由,默认返回404页面。
    
9. mux支持通配符路由,可以匹配类似/post/:id的路由。
    
10. 通过成员变量DefaultServeMux可以直接使用默认的mux。

## 通配符路由

我们在请求分发的时候，可以使用通配符来自定义路由规则，实现灵活的路由匹配，具体的使用方式如下：

1. 在路由路径中使用`:{name}`表示一个通配符：
```go
mux.HandleFunc("/users/:userid", userHandler)
```

2. 在handler函数中，通过`mux.Vars(r)`函数拿到参数名与值的映射，提取通配符的值：
```go
func userHandler(w http.ResponseWriter, r *http.Request) {
  vars := mux.Vars(r)
  id := vars["userid"] 
  // 处理请求
}
```

我们可以在一个路由中定义多个通配符：
```go
mux.HandleFunc("/posts/:postid/:commentid", commentHandler)
```

- 通配符匹配是按顺序的,会匹配类似：/posts/123/456 这样的路径。
- 未匹配上的通配符值为""，不会导致错误。
- 通配符可以和具体的值混合使用，以实现更灵活的匹配。

## Transport

Transport主要负责实现请求的发送，这里是一个代码的示例：

```go
package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
)

func main() {
	// 1. 创建 Transport
	transport := &http.Transport{}

	// 2. 使用 Transport 发送请求
	req, err := http.NewRequest("GET", "https://www.baidu.com", nil)
	resp, err := transport.RoundTrip(req)
	if err != nil {
		log.Fatal(err)
	}
	defer resp.Body.Close()

	// 3. 读取响应
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatal(err)
	}

	// 响应内容
	fmt.Println(string(body))
}

```


这里我们:

1. 创建了一个 Transport
2. 使用 Transport 的 RoundTrip 方法发送了一个请求
3. 读取了响应内容

RoundTrip 方法内部使用 Conn 来和服务器建立 TCP 连接,并通过 Conn 发送请求和读取响应。

Transport还有一些其他的方法，主要用于对连接进行配置：
- CloseIdleConnections():关闭空闲的连接
```go
transport.CloseIdleConnections()
```

- DisableKeepAlives():禁用长连接
```go
transport.DisableKeepAlives = true
```

- SetProxy():设置 HTTP 代理
```go
transport.Proxy = http.ProxyURL(proxyURL)
```

## Conn
conn代表的是与客户端(如浏览器)之间的网络连接。一个HTTP请求对应一个conn,处理完请求后conn会被关闭。

具体来说：

1. 每个HTTP请求都对应一个conn,服务器端通过这个conn与客户端通信。
    
2. 当客户端(如浏览器)发起一个HTTP请求时,会建立一个TCP连接到服务器。这个TCP连接被 Go 中 net/http包封装成一个conn。
    
3. conn内部封装了 TCP套接字,通过conn, 服务器可以读取和写入请求/响应数据。
    
4. 服务器会为每个请求分配一个goroutine处理,这个goroutine就使用这个conn与客户端通信。
    
5. 处理完请求之后,conn会被关闭,释放连接资源。

一个简单的代码示例：

```go
func handler(w http.ResponseWriter, r *http.Request) {
  Conn := r.Context().Value(http.ContextKey("conn")).(*net.Conn)
   // 通过Conn与客户端通信
}
http.HandleFunc("/", handler)
```

## Listener
Listener 负责监听传入连接，为每次连接分配 Conn，这么听着有些抽象，但在上文中，我们对服务器进行了配置：

```go
    // 启动服务 
    err := server.ListenAndServe()
    if err != nil {
        log.Fatal(err)
    }
```

```go
func main() {
  handler := &AppHandler{make(map[string]string)}
  http.Handle("/", handler)
  http.ListenAndServe(":8080", nil)
}
```

两者中的ListenAndServe函数的本质就是：
1. 创建一个 Listener,监听 8080 端口
2. 调用 mux(路由器)的 ServeHTTP 方法,处理每次 Accept() 生成的连接

具体实现为：
```go
listener, err := net.Listen("tcp", ":8080")
if err != nil {
   ...
}

for {
    conn, err := listener.Accept()  
    if err != nil {
        continue
    }
    
    // 处理请求     
    mux.ServeHTTP(conn, req, resp)
}
```

## Client 连接池

我们知道TCP连接的创建和销毁同样需要对应的资源和时间，因此我们可以配置一个连接池来进行连接的复用，这里给出一个基本的构造：

```go
package pool

import (
  "net/http"
  "time"
)

type Pool struct {
  conns chan *http.Conn 
}

func NewPool(size int) *Pool {
  return &Pool{
    conns: make(chan *http.Conn, size), 
  }
}

func (p *Pool) GetConn() *http.Conn {
  // 从池中获取连接
}

func (p *Pool) PutConn(c *http.Conn) {
  // 放回连接池
}

func (p *Pool) checkExpired() {
  // 检查过期连接,从池中移除
}

func (p *Pool) ListenAndServe(addr string, handler http.Handler) error {
  // ... 使用连接池监听端口 
}

func (p *Pool) Do(req *http.Request) (*http.Response, error) {
  conn := p.GetConn()
  resp, err := conn.Do(req)   
  p.PutConn(conn)
  return resp, err  
}

func (p *Pool) scheduleCleanup() {
   // 定期调度清理任务
}

func main() {
   pool := NewPool(100)
   pool.scheduleCleanup()

   // 接受请求   
   http.HandleFunc("/", handler)  
   pool.ListenAndServe(":8000", nil)

   // 发起请求
   req, _ := http.NewRequest("GET", "http://example.com", nil)
   resp, _ := pool.Do(req)   
}
```

## 流程解析

通过上面相关的组件的介绍，其实我们大概能将net/http包的工作原理分为四个主要阶段：端口监听、请求解析、路由分配、响应处理。更加代码化的说就是：创建 ServerSocket， 绑定并listen，accept连接，创建go协程服务一个连接。

**具体流程如下：**

1. 服务端创建`Listen Socket`，绑定并监听指定的IP地址和端口，等待客户端请求到来； `ListenAndServer(...)`
2. 客户端与`Listen Socket`连接，确认请求后，客户端得到`Client Socket`,客户端通过这个与`Listen Socket` 通信；`srv.Server(...)`
3. 服务端创建一个协程来处理客户端请求，首先从`Client Socket`读取`Http`请求的协议头和数据，交给响应的`Handler`处理，
4. `Handler`处理完毕后，结果通过`Client Socket`写给客户端。`c.server(...)`

## 参考文章
[一文带你搞懂Golang net/http包的实现原理 - 掘金 (juejin.cn)](https://juejin.cn/post/7127535913483108360?searchId=2023072813442627188C52DEB044A8D203)

---

# os

golang中的os包主要提供了访问操作系统相关功能的接口。

### 1. 文件和目录

使用os包对文件和目录进行基本操作：

```go
package main

import (
	"fmt"
	"os"
)

func main() {

	// 创建文件
	file, err := os.Create("./filename.txt")
	if err != nil {
		panic(err)
	}
	defer file.Close()

	//获取文件名称

	fileInfo, err := os.Stat("./filename.txt")
	fmt.Println(fileInfo.Name())    //获取文件名
	fmt.Println(fileInfo.IsDir())   //判断是否是目录，返回bool类型
	fmt.Println(fileInfo.ModTime()) //获取文件修改时间
	fmt.Println(fileInfo.Mode())
	fmt.Println(fileInfo.Size()) //获取文件大小
	fmt.Println(fileInfo.Sys())

	fmt.Println()

	// 写入文件内容
	file.WriteString("contents")

	// 读取文件内容
	data, err := os.ReadFile("./filename.txt")
	if err != nil {
		panic(err)
	}
	fmt.Println(string(data))

	//获取当前的工作目录的根路径
	fmt.Println(os.Getwd())

	// 重命名文件
	err = os.Rename("./filename.txt", "./new.txt")
	if err != nil {
		fmt.Println(err) // 打印详细错误信息
	}
	fmt.Println("ok")

	// 修改文件权限
	err = os.Chmod("./new.txt", 0666)

	// 创建目录
	err = os.Mkdir("./subdir", 0755)

	// 读取目录
	files, err := os.ReadDir("./subdir")
	fmt.Println(files)

	// 删除文件
	err = os.Remove("./filename.txt")

	// 删除目录
	err = os.Remove("./subdir")
}

```

### 2. 进程
```go
package main

import (
	"fmt"
	"os"
)

func main() {

	// 获取进程ID
	pid := os.Getpid()
	fmt.Println("Process ID:", pid)

	// 获取父进程ID
	ppid := os.Getppid()
	fmt.Println("Parent Process ID:", ppid)

	// 退出进程
	os.Exit(0)

	// 杀死进程(linux)
	// os.Kill(pid, syscall.SIGKILL)
	// windows
	// os.Kill(pid, os.Interrupt)

	// 获取用户ID
	uid := os.Getuid()
	fmt.Println("User ID:", uid)

	// 设置用户ID需要root权限 linux
	// os.Setuid(1000)
}
```

## 3. 环境变量

环境变量存储在内核空间，作用范围为整个应用，golang底层已经为对应的操作做好了并发安全，因此所有goroutine都可以自由读写对应的环境变量

```go
package main

import (
	"fmt"
	"os"
	"strings"
)

func main() {

	// 设置环境变量
	os.Setenv("NAME", "John")

	// 获取环境变量
	value := os.Getenv("NAME")
	fmt.Println(value) // John

	// 移除环境变量
	os.Unsetenv("NAME")

	// 获取所有环境变量
	for _, e := range os.Environ() {
		pair := strings.Split(e, "=")
		fmt.Println(pair[0], pair[1])
	}

	// 清除所有环境变量
	os.Clearenv()
}
```

## 4. 系统信息

```go
package main

import (
	"fmt"
	"os"
	"runtime"
	"os/user"
)

func main() {

	// 获取主机名
	host, err := os.Hostname()
	if err!=nil{
		fmt.Println(err)
	}
	fmt.Println(host)

	// 获取用户信息
	user, err := user.Current()
	if err!=nil{
		fmt.Println(err)
	}
	fmt.Printf("User: %s\n", user.Name)

	// 获取CPU数
	numCPU := runtime.NumCPU()
	fmt.Println("CPU: ", numCPU)

	// 获取GOMAXPROCS
	maxprocs := runtime.GOMAXPROCS(0)
	fmt.Println("GOMAXPROCS: ", maxprocs)

	// 获取当前程序启动参数
	arg := os.Args
	fmt.Println(arg)
}
```

上文中的`os.Args`可以获取启动当前Go程序的命令行参数。

它的格式是一个字符串切片,形式如下：

```go
[0:程序名 1:参数1 2:参数2 ..]
```

- `os.Args[0]`始终是当前Go程序的名字。
- `os.Args[1]`、`os.Args[2]`......则是传入的命令行参数。

举例来说就是读取下文的`one` `two` `three`
```go
go run hello.go one two three
```

## 5. 信号

下文的程序实现了两个和信号相关的功能函数：

1. 当程序启动时，default任务将一直运行，直到收到对应的`os.Interrupt`信号（通常也就是`ctrl+c`）
2. 程序等待信号，在接收到信号后对信号进行输出并打印当前的时间后退出程序
```go
package main

import (
	"fmt"
	"os"
	"os/signal"
	"syscall"
	"time"
)

func main() {
	// signalTest()
	printTime()
}

func signalTest() {
	// 监听中断信号
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)

	fmt.Println("程序已启动")

	// 监听信号chan
	for {
		select {
		case <-sigChan:
			fmt.Println("接收到中断信号，程序即将退出")
			return
		default:
			fmt.Println("程序正在运行")
			time.Sleep(time.Second)
		}
	}
}

func printTime() {
	// 监听中断信号和SIGTERM信号
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)

	// 等待信号
	fmt.Println("等待信号...")
	sig := <-sigChan
	fmt.Println("接收到信号：", sig)

	// 输出当前时间
	fmt.Println("当前时间：", time.Now())

	// 程序即将退出
	fmt.Println("程序即将退出")
}

```

## 6. I/O

### 标准输入输出

Go语言的`os`包中提供了三个表示标准输入、标准输出和标准错误输出的变量：`os.Stdin`、`os.Stdout`和`os.Stderr`。我们可以使用`os.Stdin`来读取标准输入，使用`os.Stdout`和`os.Stderr`来输出内容。

下面是一个例子：

```go
package main

import (
    "fmt"
    "os"
)

func main() {
    // 从标准输入读取数据
    fmt.Print("请输入内容：")
    var input string
    fmt.Scanln(&input)

    // 将数据写入标准输出和标准错误输出
    fmt.Fprintln(os.Stdout, "这是标准输出：", input)
    fmt.Fprintln(os.Stderr, "这是标准错误输出：", input)
}
```

### 进程IO

Go语言的`os`包中提供了`os.StartProcess`函数，可以启动一个新的进程，并指定输入、输出和错误输出的文件描述符。该函数返回一个`*os.Process`对象，可以使用该对象来控制新进程的行为。

该程序会启动一个`ls -l`命令，并将其输出重定向到文件`output.txt`中：

```go
package main

import (
    "fmt"
    "os"
    "os/exec"
)

func main() {
    // 创建一个命令
    cmd := exec.Command("ls", "-l")

    // 打开一个文件，用于保存命令的输出
    file, err := os.Create("output.txt")
    if err != nil {
        fmt.Println("创建文件失败：", err)
        return
    }

    // 将命令的标准输出和标准错误输出重定向到文件
    cmd.Stdout = file
    cmd.Stderr = file

    // 启动命令
    err = cmd.Start()
    if err != nil {
        fmt.Println("启动命令失败：", err)
        return
    }

    // 等待命令执行完毕
    err = cmd.Wait()
    if err != nil {
        fmt.Println("等待命令执行失败：", err)
        return
    }

    fmt.Println("命令执行完成")
}
```

### 管道操作

Go语言的`os`包中提供了`os.Pipe`函数，可以创建一个匿名管道，用于进程间通信。该函数返回两个`*os.File`对象，一个表示管道的读取端，一个表示管道的写入端。我们可以在两个进程之间使用这两个文件对象来传递数据。

```go
package main

import (
    "fmt"
    "io"
    "os"
)

func main() {
    // 创建一个管道
    reader, writer, err := os.Pipe()
    if err != nil {
        fmt.Println("创建管道失败：", err)
        return
    }

    // 启动一个协程，向管道中写入数据
    go func() {
        defer writer.Close()
        fmt.Fprintln(writer, "这是一条来自子进程的消息")
    }()

    // 从管道中读取数据
    buf := make([]byte, 1024)
    n, err := reader.Read(buf)
    if err != nil && err != io.EOF {
        fmt.Println("读取数据失败：", err)
        return
    }

    fmt.Println("收到一条来自子进程的消息：", string(buf[:n]))
}
```

## 7. 用户和群组

```go
package main

import (
    "fmt"
    "os"
    "os/user"
)

func main() {
    // 获取当前用户信息
    currentUser, err := user.Current()
    if err != nil {
        fmt.Println("获取当前用户信息失败：", err)
        return
    }

    fmt.Println("当前用户信息：", currentUser.Username, currentUser.HomeDir)

    // 根据用户名获取用户信息
    userInfo, err := user.Lookup("root")
    if err != nil {
        fmt.Println("获取用户信息失败：", err)
        return
    }

    fmt.Println("用户信息：", userInfo.Username, userInfo.Uid, userInfo.HomeDir)

    // 根据用户ID获取用户信息
    userInfo, err = user.LookupId("0")
    if err != nil {
        fmt.Println("获取用户信息失败：", err)
        return
    }

    fmt.Println("用户信息：", userInfo.Username, userInfo.Uid, userInfo.HomeDir)

    // 根据群组名获取群组信息
    groupInfo, err := user.LookupGroup("root")
    if err != nil {
        fmt.Println("获取群组信息失败：", err)
        return
    }

    fmt.Println("群组信息：", groupInfo.Name, groupInfo.Gid)

    // 根据群组ID获取群组信息
    groupInfo, err = user.LookupGroupId("0")
    if err != nil {
        fmt.Println("获取群组信息失败：", err)
        return
    }

    fmt.Println("群组信息：", groupInfo.Name, groupInfo.Gid)

    // 打开文件
    file, err := os.Create("test.txt")
    if err != nil {
        fmt.Println("创建文件失败：", err)
        return
    }
    defer file.Close()

    // 设置文件所有者
    err = file.Chown(0, 0)
    if err != nil {
        fmt.Println("设置文件所有者失败：", err)
        return
    }

    // 设置文件权限
    err = file.Chmod(0644)
    if err != nil {
        fmt.Println("设置文件权限失败：", err)
        return
    }

    fmt.Println("文件所有者和权限设置完成")
}
```


## 8. CPU

我们可以使用os包中的操作获取到当前机器的CPU个数，

```go
package main

import (
	"fmt"
	"os"
	"runtime"
	"strconv"
)

func main() {

	// 返回系统的CPU数
	cpuNum := os.Getenv("GOMAXPROCS")
	if cpuNum == "" {
		cpuNum = strconv.Itoa(runtime.NumCPU())
	}
	fmt.Printf("CPU number: %s\n", cpuNum)

	// 设置最大使用的CPU数
	runtime.GOMAXPROCS(runtime.NumCPU())

	// 返回cgo调用次数
	fmt.Printf("Number of cgo calls: %d\n", runtime.NumCgoCall())

}

```

OS包中同样提供一些操作来设置CPU亲和性，限制程序运行在指定的CPU上，这里不再赘述。

# time 

`time`包提供了很多方便的功能用来操作与时间相关的信息：
- 获取系统时间:使用`time.Now()`可以获取当前的时间。
- 定时和延时:使用`time.Sleep()`可以延时指定的时间间隔。
- 格式化和解析时间:
    - 使用`time.Format()`格式化时间。
    - 使用`time.Parse()`解析时间字符串。
- 时间运算:
    - 使用`time.Since()`获取两个时间点之间的间隔。
    - 使用`time.Add()`添加时间间隔到时间点上。

- 时区处理:
    - 使用`time.LoadLocation()`加载某个时区。
    - 使用`time.In()`转换时区。
- 时间比较:
    - 使用`time.Before()`比较两个时间点。
- 定时器:
    - 使用`time.NewTimer()`创建定时器。


```go
package main

import (
	"fmt"
	"time"
)

func main() {

	// 1. 获取当前时间
	now := time.Now()

	// 2. 暂停程序
	time.Sleep(2 * time.Second)

	// 3. 格式化时间
	format := now.Format("2006/01/02 15:04:05")
	fmt.Println(format)

	// 4. 时区转换
	loc, _ := time.LoadLocation("Local")
	locTime := now.In(loc)
	fmt.Println(locTime)

	// 5. 解析时间戳
	timestamp := now.Unix()
	t := time.Unix(timestamp, 0)

	// 6. 日期计算
	t = t.Add(24 * time.Hour)

	// 7. 比较时间
	t1 := time.Now()
	if t1.Before(t) {

	}

	// 8. 定时器
	timer := time.NewTimer(5 * time.Second)
	<-timer.C // 等待5秒

	// 9. 经过时间
	duration := time.Since(t1)
	fmt.Println(duration)

	// 10. 本地时间
	fmt.Println(time.Now().Local())

	// 11. 常量
	second := time.Second
	fmt.Println(second)
}

```

# sort

sort包中含有负责对切片进行排序的函数，这里列出常用的几个函数：

|函数|描述|
|---|---|
|Ints(x []int)|对 int 类型的切片进行升序排序|
|IntsAreSorted(x []int) bool|判断 int 类型的切片是否是升序排序|
|Float64s(x []float64)|对 float64 类型的切片进行升序排序|
|Float64sAreSorted(x []float64) bool|判断 float64 类型的切片是否是升序排序|
|Strings(x []string)|对 string 类型的切片进行升序排序|
|StringsAreSorted(x []string) bool|判断 string 类型的切片是否是升序排序|
|Sort(data Interface)|对自定义类型的切片进行排序，自定义类型必须实现 Interface 接口|

这里给出一个例子演示对应的排序方式与自定义类型的排序和多级排序：

```go
package main

import (
	"fmt"
	"sort"
)

func main() {
	basicSort()
	diyTypeSort()
}

func basicSort() {
	//对int类型的切片进行排序
	intSlice := []int{8, 3, 9, 7, 1}
	sort.Ints(intSlice)
	fmt.Println("Sorted int slice:", intSlice)

	//对float64类型的切片进行排序
	floatSlice := []float64{5.6, 1.3, 3.4, 2.2, 7.8}
	sort.Float64s(floatSlice)
	fmt.Println("Sorted float slice:", floatSlice)

	//对string类型的切片进行排序
	stringSlice := []string{"apple", "cat", "banana", "dog"}
	sort.Strings(stringSlice)
	fmt.Println("Sorted string slice:", stringSlice)

	//判断int类型的切片是否已经按升序排序
	fmt.Println("Is int slice sorted:", sort.IntsAreSorted(intSlice))

	//判断float64类型的切片是否已经按升序排序
	fmt.Println("Is float slice sorted:", sort.Float64sAreSorted(floatSlice))

	//判断string类型的切片是否已经按升序排序
	fmt.Println("Is string slice sorted:", sort.StringsAreSorted(stringSlice))
}

// 创建自定义类型，实现对应的三个排序接口
type Person struct {
	Name string
	Age  int
}

type ByAge []Person

func (a ByAge) Len() int      { return len(a) }
func (a ByAge) Swap(i, j int) { a[i], a[j] = a[j], a[i] }

//只对Age排序
// func (a ByAge) Less(i, j int) bool { return a[i].Age < a[j].Age }

// 多重排序
func (a ByAge) Less(i, j int) bool {
	if a[i].Age == a[j].Age {
		return a[i].Name < a[j].Name
	}
	return a[i].Age < a[j].Age
}

func diyTypeSort() {
	persons := []Person{
		{"Tom", 23},
		{"Alice", 18},
		{"Bob", 27},
		{"Jane", 21},
		{"Zoe", 21},
	}

	// 实现排序
	sort.Sort(ByAge(persons))
	fmt.Println("\nSorted by age:", persons)

	// 实现排序反转
	sort.Sort(sort.Reverse(ByAge(persons)))
	fmt.Println("\nReverse:", ByAge(persons))
}

```

从上面的代码可以看出，在golang中，想要一个自定义类型实现sort功能，则对应的切片对象需要实现三个接口：
```go
func (a ByAge) Len() int      { return len(a) }
func (a ByAge) Swap(i, j int) { a[i], a[j] = a[j], a[i] }
func (a ByAge) Less(i, j int) bool { return a[i].Age < a[j].Age }
```

实现了这三个接口之后，我们就可以使用sort包中提供的函数来进行排序，而如果需要多级排序功能，我们可以手动修改Less函数中的判定方式，手动实现多级的排序功能：
```go
func (a ByAge) Less(i, j int) bool {
	if a[i].Age == a[j].Age {
		return a[i].Name < a[j].Name
	}
	return a[i].Age < a[j].Age
}
```

可能你会注意到，我们在对自定义结构体进行排序的时候的流程如下：

```go
// 实现排序
sort.Sort(ByAge(persons))
fmt.Println("\nSorted by age:", persons)
```

而对排序结果进行反转的时候则需要：

```go
// 实现排序反转
sort.Sort(sort.Reverse(ByAge(persons)))
fmt.Println("\nReverse:", ByAge(persons))
```

这是由于`sort.Reverse`函数其实不对`ByAge(persons)`本身进行排序，它只是单纯的修改了`ByAge(persons)`中的Less方法，并返回对应的`sort`接口，并没有执行排序操作，所以我们需要再次使用`sort.Sort`执行一次反转操作。

## 参考文章

[一文掌握使用 Go 标准库 sort 对切片进行排序 - 掘金 (juejin.cn)](https://juejin.cn/post/7179260634872152119?searchId=20230729162718766F35654DB0D972482E)

---

# strconv

strconv包主要负责实现各类数据类型与字符串的相互转换

### 1.string转int

有两种方法，可以使用`func Atoi(s string) (i int, err error)`，Atoi代表Ascii to Integer，这一点上与C语言类似。还可以使用`func ParseInt(s string, base int, bitSize int) (i int64, err error)`，base为进制，值为2~36，如果为0，则会根据字符串自动判断，前置为"0x"的是16进制，前置为"0"的是8进制，其余的为10进制，bitSize是返回的整数类型，0、8、16、32分别代表int、int8、int16、int32。




```Go
func main() {	a,_:=strconv.Atoi("123456")	fmt.Printf("a values %v\n",a)	b,_:=strconv.ParseInt("123456",10,32)	fmt.Printf("b values %v\n",b)	c,_:=strconv.ParseInt("123456",10,16)	fmt.Printf("c values %v\n",c)	d,_:=strconv.ParseInt("111",2,32)	fmt.Printf("d values %v\n",d)}
```

以上代码会打印出

a values 123456  
b values 123456  
c values 32767  
d values 7  
看一下c，由于返回的是int16类型的值，int16类型的值的范围为-32768~32767，超过了返回类型的范围，会被截断，所以选择返回值类型时要选择正确。

### 2.int转string

使用func Itoa(i int) string方法，将int类型的转string类型。

```Go
func main() {	var i int = 12345	s:=strconv.Itoa(i)	fmt.Printf("s values %v,type is %T",s,s)}
```

以上会输出

s values 12345,type is string

### 3.string转bool

```Go
func main(){	
	fmt.Println(strconv.ParseBool("t"))	
	fmt.Println(strconv.ParseBool("TRUE"))	
	fmt.Println(strconv.ParseBool("true"))	
	fmt.Println(strconv.ParseBool("True"))	
	fmt.Println(strconv.ParseBool("0"))	
	fmt.Println(strconv.ParseBool("f"))
}
```

以上会输出
```go
true <nil>  
true <nil>  
true <nil>  
true <nil>  
false <nil>  
false <nil>
```


### 4.string转float

func ParseFloat(s string, bitSize int) (f float64, err error)

```Go
mian(){	f,err:=strconv.ParseFloat("20.58",64)	if err!=nil {		panic(err)	}	fmt.Printf("%v,%T",f,f)}
```

输出

20.58,float64

### 5.float转string

func FormatFloat(f float64, fmt byte, prec, bitSize int) string

其中fmt表示格式，’f’（-ddd.dddd）、’b’（-ddddp±ddd，指数为二进制）、’e’（-d.dddde±dd，十进制指数）、’E’（-d.ddddE±dd，十进制指数）、’g’（指数很大时用’e’格式，否则’f’格式）、’G’（指数很大时用’E’格式，否则’f’格式）；prec表示控制的精度（排除指数部分）：对’f’、’e’、’E’，它表示小数点后的数字个数；对’g’、’G’，它控制总的数字个数。如果prec 为-1，则代表使用最少数量的、但又必需的数字来表示f。

```Go
mian(){	str:=strconv.FormatFloat(23.5670,'f',-1,64)	str2:=strconv.FormatFloat(23.5670,'f',5,64)	fmt.Println(str)	fmt.Println(str2)}
```

输出

23.567  
23.56700


除了字符串与类型之间的相互转换之外，strconv包还能将各种基本类型追加到字节数组中，或是对带引号的字符串做出转换：

```go
package main

import (
    "fmt"
    "strconv"
)

func main() {
    // 将整数类型追加到字节数组中
    b1 := make([]byte, 0, 100)
    b1 = strconv.AppendInt(b1, 123, 10)
    fmt.Printf("Type: %T, Value: %v\n", b1, string(b1))

    // 将无符号整数类型追加到字节数组中
    b2 := make([]byte, 0, 100)
    b2 = strconv.AppendUint(b2, 456, 10)
    fmt.Printf("Type: %T, Value: %v\n", b2, string(b2))

    // 将布尔值类型追加到字节数组中
    b3 := make([]byte, 0, 100)
    b3 = strconv.AppendBool(b3, true)
    fmt.Printf("Type: %T, Value: %v\n", b3, string(b3))

    // 将浮点数类型追加到字节数组中
    b4 := make([]byte, 0, 100)
    b4 = strconv.AppendFloat(b4, 3.14, 'f', 2, 64)
    fmt.Printf("Type: %T, Value: %v\n", b4, string(b4))

    // 将字符串转换为带引号的字符串
    s1 := strconv.Quote("hello world")
    fmt.Printf("Type: %T, Value: %v\n", s1, s1)

    // 将带引号的字符串转换为普通字符串
    s2, err := strconv.Unquote(`"hello world"`)
    if err != nil {
        fmt.Println("error:", err)
    }
    fmt.Printf("Type: %T, Value: %v\n", s2, s2)

    // 将 rune 类型的字符转换为带引号的字符串
    s3 := strconv.QuoteRune('中')
    fmt.Printf("Type: %T, Value: %v\n", s3, s3)

    // 将带引号的字符串转换为 rune 类型的字符
    r, _, err := strconv.UnquoteChar(`'\u4e2d'`, '\'')
    if err != nil {
        fmt.Println("error:", err)
    }
    fmt.Printf("Type: %T, Value: %v\n", r, r)
}
```


## 参考文章
[GO语言中的strconv包_go strconv_杨鲜生的博客-CSDN博客](https://blog.csdn.net/u013252047/article/details/104891177)
[Go语言之strconv - 不会钓鱼的猫 - 博客园 (cnblogs.com)](https://www.cnblogs.com/cqzlei/articles/16949979.html)

# strings
stirngs包中包含了许多常规的字符串操作函数，例如：
1. 字符串查找和替换函数：用于查找和替换字符串中的子串。
    
    - `Contains` 函数用于判断一个字符串是否包含另一个字符串。
    - `Index` 和 `LastIndex` 函数用于查找字符串中某个子串的位置。
    - `Replace` 函数用于将字符串中的某个子串替换为另一个字符串。
2. 字符串分割和连接函数：用于分割和连接字符串。
    
    - `Split` 函数用于将字符串按照指定的分隔符分割为多个子串。
    - `Join` 函数用于将多个字符串连接起来，中间用指定的分隔符隔开。
3. 字符串切割和修剪函数：用于切割和修剪字符串。
    
    - `Trim` 函数用于去掉字符串开头和结尾的指定字符。
    - `TrimLeft` 和 `TrimRight` 函数用于去掉字符串开头或结尾的指定字符。
    - `Fields` 函数用于将字符串按照空格分割为多个子串。
4. 字符串大小写转换函数：用于将字符串转换为大写或小写形式。
    
    - `ToUpper` 函数用于将字符串转换为大写形式。
    - `ToLower` 函数用于将字符串转换为小写形式。
5. 字符串比较函数：用于比较字符串的大小关系。
    
    - `Compare` 函数用于比较两个字符串的大小关系。
这里提供一个例子：

```go
package main

import (
    "fmt"
    "strings"
)

func main() {
    // 判断字符串是否包含另一个字符串
    fmt.Println(strings.Contains("hello world", "world"))

    // 查找字符串中某个子串的位置
    fmt.Println(strings.Index("hello world", "world"))

    // 将字符串中的某个子串替换为另一个字符串
    fmt.Println(strings.Replace("hello world", "world", "golang", -1))

    // 将字符串按照指定的分隔符分割为多个子串
    fmt.Println(strings.Split("hello world", " "))

    // 将多个字符串连接起来，中间用指定的分隔符隔开
    fmt.Println(strings.Join([]string{"hello", "world"}, " "))

    // 去掉字符串开头和结尾的指定字符
    fmt.Println(strings.Trim(" hello ", " "))

    // 将字符串转换为大写形式
    fmt.Println(strings.ToUpper("hello world"))

    // 比较两个字符串的大小关系
    fmt.Println(strings.Compare("hello world", "Hello World"))
}
```

除了这些函数之外，还有一些其他的进阶函数：
1. `FieldsFunc`：根据给定的函数将字符串分割成多个子串。分割函数应该返回一个布尔值，指示是否应该在当前位置分割字符串。
2. `IndexFunc` 和 `LastIndexFunc`：根据给定的函数查找字符串中某个字符的位置。查找函数应该返回一个布尔值，指示是否在当前位置找到了字符。
3. `Map`：将字符串中的每个字符都映射到另一个字符。映射函数接受一个字符并返回另一个字符。
4. `NewReader`：将字符串包装在一个 `io.Reader` 接口中，以便可以像读取文件一样读取它。
5. `NewReplacer`：创建一个 `strings.Replacer` 对象，用于执行多个字符串替换操作。
6. `SplitAfter` 和 `SplitAfterN`：按照指定的后缀分隔字符串。
7. `Title` 和 `ToTitle`：将字符串中的每个单词的首字母大写，并将所有字符转换为标题大小写。
8. `ToValidUTF8`：将字符串中的无效 UTF-8 字符替换为指定的替代字符。
9. `TrimLeftFunc` 和 `TrimRightFunc`：将字符串开头或结尾的所有满足指定条件的字符都删除。
10. `ValidUTF8`：检查字符串是否包含有效的 UTF-8 字符，将无效的字符进行转换。

```go
package main

import (
    "fmt"
    "strings"
)

func main() {
	// 根据给定的函数将字符串分割成多个子串
	f := func(c rune) bool {
		return c == ' ' || c == ','
	}
	fmt.Println(strings.FieldsFunc("hello, world", f))

	// 根据给定的函数查找字符串中某个字符的位置
	f2 := func(c rune) bool {
		return c == 'o'
	}
	fmt.Println(strings.IndexFunc("hello world", f2))
	fmt.Println(strings.LastIndexFunc("hello world", f2))

	// 将字符串中的每个字符都映射到另一个字符
	f3 := func(c rune) rune {
		if c >= 'a' && c <= 'z' {
			return c - 'a' + 'A'
		}
		return c
	}
	fmt.Println(strings.Map(f3, "hello world"))

	// 将字符串包装在一个 io.Reader 接口中
	r := strings.NewReader("hello world")
	buf := make([]byte, 5)
	r.Read(buf)
	fmt.Println(string(buf))

	// 创建一个 strings.Replacer 对象，用于执行多个字符串替换操作
	r2 := strings.NewReplacer("hello", "hi", "world", "golang")
	fmt.Println(r2.Replace("hello world"))

	// 按照指定的后缀分隔字符串
	fmt.Println(strings.SplitAfter("hello,world,", ","))

	// 将字符串中的每个单词的首字母大写，并将所有字符转换为标题大小写
	fmt.Println(strings.Title("hello world"))
	fmt.Println(strings.ToTitle("hello world"))

	// 将字符串开头或结尾的所有满足指定条件的字符都删除
	f4 := func(c rune) bool {
		return c == ' '
	}
	fmt.Println(strings.TrimLeftFunc("   hello world   ", f4))
	fmt.Println(strings.TrimRightFunc("   hello world   ", f4))

	// 检查字符串是否包含有效的 UTF-8 字符,将无效的字符进行转换
	fmt.Println(strings.ToValidUTF8("hello world", " "))
}
```

# sync
